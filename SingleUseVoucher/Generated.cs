//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace Electrum.SingleUseVoucher
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Client 
    {
        private string _baseUrl = "https://sandbox.electrum.io/suv/v1";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public Client(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Retrieve products, filtered using the query parameter(s).
        /// </summary>
        /// <param name="channelName">The name of the channel to retrieve products for. If set only products matching this channel name will be returned. If not set, all products will be returned.</param>
        /// <param name="receiverId">The unique Id of the receiving entity from which to retrieve the list of products.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ProductsLookupResponse> ProductsAsync(string channelName, string receiverId)
        {
            return ProductsAsync(channelName, receiverId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieve products, filtered using the query parameter(s).
        /// </summary>
        /// <param name="channelName">The name of the channel to retrieve products for. If set only products matching this channel name will be returned. If not set, all products will be returned.</param>
        /// <param name="receiverId">The unique Id of the receiving entity from which to retrieve the list of products.</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ProductsLookupResponse> ProductsAsync(string channelName, string receiverId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/products?");
            if (channelName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("channelName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(channelName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (receiverId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("receiverId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(receiverId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProductsLookupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Redeems a voucher.
        /// </summary>
        /// <param name="body">A redemption request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<RedemptionResponse> RedemptionsPostAsync(RedemptionRequest body)
        {
            return RedemptionsPostAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Redeems a voucher.
        /// </summary>
        /// <param name="body">A redemption request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RedemptionResponse> RedemptionsPostAsync(RedemptionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/redemptions");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RedemptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RedemptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Confirm a voucher redemption request that completed successfully.
        /// </summary>
        /// <param name="body">A voucher redemption confirmation.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicAdvice> RedemptionsConfirmationsAsync(BasicAdvice body)
        {
            return RedemptionsConfirmationsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Confirm a voucher redemption request that completed successfully.
        /// </summary>
        /// <param name="body">A voucher redemption confirmation.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicAdvice> RedemptionsConfirmationsAsync(BasicAdvice body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/redemptions/confirmations");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdvice>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdvice>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reverse a voucher redemption request.
        /// </summary>
        /// <param name="body">A voucher redemption reversal.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicReversal> RedemptionsReversalsAsync(BasicReversal body)
        {
            return RedemptionsReversalsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reverse a voucher redemption request.
        /// </summary>
        /// <param name="body">A voucher redemption reversal.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicReversal> RedemptionsReversalsAsync(BasicReversal body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/redemptions/reversals");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicReversal>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicReversal>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Looks up and returns the outcome of a prior voucher redemption.
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<RedemptionResponse> RedemptionsGetAsync(string requestId)
        {
            return RedemptionsGetAsync(requestId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Looks up and returns the outcome of a prior voucher redemption.
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RedemptionResponse> RedemptionsGetAsync(string requestId, System.Threading.CancellationToken cancellationToken)
        {
            if (requestId == null)
                throw new System.ArgumentNullException("requestId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/redemptions/{requestId}");
            urlBuilder_.Replace("{requestId}", System.Uri.EscapeDataString(ConvertToString(requestId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 102)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Processing", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RedemptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Refunds a voucher.
        /// </summary>
        /// <param name="body">A refund request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<RefundResponse> RefundsAsync(RefundRequest body)
        {
            return RefundsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Refunds a voucher.
        /// </summary>
        /// <param name="body">A refund request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RefundResponse> RefundsAsync(RefundRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/refunds");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RefundResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RefundResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Confirm a voucher refund request that completed successfully.
        /// </summary>
        /// <param name="body">A voucher refund confirmation.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicAdvice> RefundsConfirmationsAsync(BasicAdvice body)
        {
            return RefundsConfirmationsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Confirm a voucher refund request that completed successfully.
        /// </summary>
        /// <param name="body">A voucher refund confirmation.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicAdvice> RefundsConfirmationsAsync(BasicAdvice body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/refunds/confirmations");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdvice>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdvice>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reverse a voucher refund request.
        /// </summary>
        /// <param name="body">A voucher refund reversal.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicReversal> RefundsReversalsAsync(BasicReversal body)
        {
            return RefundsReversalsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reverse a voucher refund request.
        /// </summary>
        /// <param name="body">A voucher refund reversal.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicReversal> RefundsReversalsAsync(BasicReversal body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/refunds/reversals");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicReversal>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicReversal>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Lookup a voucher using the voucher code.
        /// </summary>
        /// <param name="voucherCode">The voucher code to be looked up.</param>
        /// <param name="provisionRequestId">The provision request id that was part of the original provision request to obtain a voucher.</param>
        /// <param name="receiverInstId">The institution which issued the voucher. This assists to direct the voucher lookup request if the destination cannot be determined from the voucher code alone.</param>
        /// <param name="settlementEntityInstId">The institution via which the lookup should be processed. This serves to better direct the lookup request in the case that multiple upstream parties are able to process the request.</param>
        /// <param name="voucherSerialNumber">The serial number of the voucher being looked up.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<VoucherLookupResponse> VouchersGetAsync(string voucherCode, string provisionRequestId, string receiverInstId, string settlementEntityInstId, string voucherSerialNumber)
        {
            return VouchersGetAsync(voucherCode, provisionRequestId, receiverInstId, settlementEntityInstId, voucherSerialNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Lookup a voucher using the voucher code.
        /// </summary>
        /// <param name="voucherCode">The voucher code to be looked up.</param>
        /// <param name="provisionRequestId">The provision request id that was part of the original provision request to obtain a voucher.</param>
        /// <param name="receiverInstId">The institution which issued the voucher. This assists to direct the voucher lookup request if the destination cannot be determined from the voucher code alone.</param>
        /// <param name="settlementEntityInstId">The institution via which the lookup should be processed. This serves to better direct the lookup request in the case that multiple upstream parties are able to process the request.</param>
        /// <param name="voucherSerialNumber">The serial number of the voucher being looked up.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<VoucherLookupResponse> VouchersGetAsync(string voucherCode, string provisionRequestId, string receiverInstId, string settlementEntityInstId, string voucherSerialNumber, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/vouchers?");
            if (voucherCode != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("voucherCode") + "=").Append(System.Uri.EscapeDataString(ConvertToString(voucherCode, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (provisionRequestId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("provisionRequestId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(provisionRequestId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (receiverInstId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("receiverInstId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(receiverInstId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (settlementEntityInstId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("settlementEntityInstId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(settlementEntityInstId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (voucherSerialNumber != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("voucherSerialNumber") + "=").Append(System.Uri.EscapeDataString(ConvertToString(voucherSerialNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VoucherLookupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VoucherLookupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Request a voucher be provisioned.
        /// </summary>
        /// <param name="body">A provision request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ProvisionResponse> VouchersPostAsync(ProvisionRequest body)
        {
            return VouchersPostAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request a voucher be provisioned.
        /// </summary>
        /// <param name="body">A provision request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ProvisionResponse> VouchersPostAsync(ProvisionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/vouchers");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProvisionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProvisionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Confirm a voucher provision request that completed successfully.
        /// </summary>
        /// <param name="body">A voucher provision confirmation.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<TenderAdvice> VouchersConfirmationsAsync(TenderAdvice body)
        {
            return VouchersConfirmationsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Confirm a voucher provision request that completed successfully.
        /// </summary>
        /// <param name="body">A voucher provision confirmation.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TenderAdvice> VouchersConfirmationsAsync(TenderAdvice body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/vouchers/confirmations");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TenderAdvice>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TenderAdvice>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reverse a voucher provision request that failed or timed out.
        /// </summary>
        /// <param name="body">A voucher provision reversal.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicReversal> VouchersReversalsAsync(BasicReversal body)
        {
            return VouchersReversalsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reverse a voucher provision request that failed or timed out.
        /// </summary>
        /// <param name="body">A voucher provision reversal.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicReversal> VouchersReversalsAsync(BasicReversal body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/vouchers/reversals");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicReversal>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicReversal>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Retry a voucher that was not successfully provisioned.
        /// </summary>
        /// <param name="provisionId">The UUID generated for the original voucher provision request.</param>
        /// <param name="body">The original voucher provision request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ProvisionResponse> VouchersRetryAsync(string provisionId, ProvisionRequest body)
        {
            return VouchersRetryAsync(provisionId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retry a voucher that was not successfully provisioned.
        /// </summary>
        /// <param name="provisionId">The UUID generated for the original voucher provision request.</param>
        /// <param name="body">The original voucher provision request.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ProvisionResponse> VouchersRetryAsync(string provisionId, ProvisionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (provisionId == null)
                throw new System.ArgumentNullException("provisionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/vouchers/{provisionId}/retry");
            urlBuilder_.Replace("{provisionId}", System.Uri.EscapeDataString(ConvertToString(provisionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProvisionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProvisionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Model for an account-to-account payment method
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccountPayment : PaymentMethod
    {
        /// <summary>
        /// Source AccountId from which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SrcAccountId { get; set; }

        /// <summary>
        /// Source CustomerId from which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcCustomerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SrcCustomerId { get; set; }

        /// <summary>
        /// Destination AccountId to which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestAccountId { get; set; }

        /// <summary>
        /// Destination CustomerId to which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destCustomerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestCustomerId { get; set; }

    }

    /// <summary>
    /// Details of a customer's address
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Address
    {
        /// <summary>
        /// First line of street address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addressLine1", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^.{1,100}")]
        public string AddressLine1 { get; set; }

        /// <summary>
        /// Second line of street address (if required).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addressLine2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^.{1,100}")]
        public string AddressLine2 { get; set; }

        /// <summary>
        /// The city where the owner is located. Note: if this field ever needs to be translated to another API with shorter fields, the field will be truncated from the right.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("city", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^.{1,30}")]
        public string City { get; set; }

        /// <summary>
        /// The state or region where the owner is located.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z]{2}")]
        public string Region { get; set; }

        /// <summary>
        /// The owner's resident country expressed as an ISO 3166-1 Alpha-2 code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z]{2}")]
        public string Country { get; set; }

        /// <summary>
        /// The owner's postal code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("postalCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Za-z0-9 -]{1,20}")]
        public string PostalCode { get; set; }

    }

    /// <summary>
    /// Amounts which make up the transaction. Absent amounts have zero value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Amounts
    {
        /// <summary>
        /// The transaction amount requested by the customer to be authorised or approved. This is the total amount the customer wishes to pay for a service or virtual product.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount RequestAmount { get; set; }

        /// <summary>
        /// The transaction amount which was approved by the upstream entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("approvedAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount ApprovedAmount { get; set; }

        /// <summary>
        /// Fees charged by the upstream entity for processing the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount FeeAmount { get; set; }

        /// <summary>
        /// The remaining balance on the customer's account.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("balanceAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount BalanceAmount { get; set; }

        /// <summary>
        /// Any additional amounts that are involved in a transaction which don't appropriately fit into the other amount fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalAmounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LedgerAmount> AdditionalAmounts { get; set; }

    }

    /// <summary>
    /// Model for token-based payments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class An32TokenPayment : PaymentMethod
    {
        /// <summary>
        /// 32 character alphanumeric code which identifies a token
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[a-zA-Z0-9]{32}")]
        public string Token { get; set; }

    }

    /// <summary>
    /// Used to indicate barcode information for a slip line.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Barcode
    {
        /// <summary>
        /// Data to be encoded in the barcode
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Data { get; set; }

        /// <summary>
        /// Specifies the encoding used in the barcode
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Encoding { get; set; }

    }

    /// <summary>
    /// The data required in all advice messages
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BasicAdvice
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

    }

    /// <summary>
    /// An advice that notifies of the negative completion of a transaction. This can be either due to customer cancellation, or as a result of receiving a non-final response (or no response) to a request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BasicReversal
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// The reason for the reversal
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reversalReason", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BasicReversalReversalReason ReversalReason { get; set; }

    }

    /// <summary>
    /// Model for card-based payments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CardPayment : PaymentMethod
    {
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

        /// <summary>
        /// The PIN associated with this card as either a clear PIN or an encrypted PIN in HEX format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pin Pin { get; set; }

        /// <summary>
        /// Primary account number that uniquely identifies this card.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pan", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{1,19}")]
        public string Pan { get; set; }

        /// <summary>
        /// The card expiry date, in YYMM format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiryDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{4}")]
        public string ExpiryDate { get; set; }

        /// <summary>
        /// Data used to facilitate and communicate the result of 3-D Secure cardholder authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("threeDSecureData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ThreeDSecureData ThreeDSecureData { get; set; }

        /// <summary>
        /// The encrypted pin number associated with the card in HEX format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedPin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptedPin EncryptedPin { get; set; }

    }

    /// <summary>
    /// A customer who ultimately requests a transaction be performed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Customer
    {
        /// <summary>
        /// The customer's first name(s)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string FirstName { get; set; }

        /// <summary>
        /// The customer's last name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string LastName { get; set; }

        /// <summary>
        /// The customer's address
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(80)]
        public string Address { get; set; }

        /// <summary>
        /// The customer's date of birth
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateOfBirth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DateOfBirth { get; set; }

        /// <summary>
        /// The status of this customer on the Giftcard system. For example: active, inactive
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        /// <summary>
        /// This must conform to the ITU E.164 numbering plan (https://www.itu.int/rec/T-REC-E.164/en) e.g. 27821234567 for a South African number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("msisdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\+?[1-9]\d{0,14}")]
        public string Msisdn { get; set; }

        /// <summary>
        /// The customer's email address. This address must conform to RFC 5322 3.4.1 addr-spec (https://tools.ietf.org/html/rfc5322#section-3.4.1).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emailAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EmailAddress { get; set; }

        /// <summary>
        /// The customer's address details.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addressDetails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Address AddressDetails { get; set; }

        /// <summary>
        /// The customer's profile ID. Used to uniquely identify a customer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("profileId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProfileId { get; set; }

    }

    /// <summary>
    /// A PIN required to authorise a transaction. EncryptionParameters should be provided where the service will be performing operations on the encrypted PIN, such as PIN translation. Only the PIN block need be provided where the service is expected to forward it to a third party, where the calling client and said third party have agreed upon encryption parameters beforehand.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EncryptedPin
    {
        /// <summary>
        /// Hexadecimal string representing the encrypted PIN to be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinBlock", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[a-fA-F0-9]{16}")]
        public string PinBlock { get; set; }

        /// <summary>
        /// Parameters pertaining to the generation of the pinBlock. Required if the service is to perform any operations on the encrypted PIN, such as PIN translation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptionParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptionParameters EncryptionParameters { get; set; }

    }

    /// <summary>
    /// Parameters pertaining to the generation of the PIN block. Required if the service is to perform any operations on the encrypted PIN, such as translation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EncryptionParameters
    {
        /// <summary>
        /// PIN block format that was used when encrypting the PIN. Defaults to ISO_9564_FORMAT_0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinBlockFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EncryptionParametersPinBlockFormat? PinBlockFormat { get; set; } = Electrum.SingleUseVoucher.EncryptionParametersPinBlockFormat.ISO_9564_FORMAT_0;

        /// <summary>
        /// 12 digit account number used when encrypting the PIN. When account number is a card number (PAN), this is the rightmost 12 digits excluding the check digit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{12}")]
        public string AccountNumber { get; set; }

        /// <summary>
        /// Index of the key under which the PIN block is encrypted. Where keys are exchanged in TR-31 KeyBlock format, this should be set to the key version number field of the key used for encryption. If this field is not populated, the most recently exchanged key will be used. Note that omitting this field may require a higher level of synchronization during automated key exchange in some environments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyIndex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? KeyIndex { get; set; }

    }

    /// <summary>
    /// Represents the reasons an operation has failed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorDetail
    {
        /// <summary>
        /// The randomly generated UUID identifying the message which caused the ErrorDetail, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID of the original request message in the case of an error occurring for an advice message
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OriginalId { get; set; }

        /// <summary>
        /// The type of error that occurred
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ErrorDetailErrorType ErrorType { get; set; }

        /// <summary>
        /// A short description of the error
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorMessage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(80)]
        public string ErrorMessage { get; set; }

        /// <summary>
        /// The response code received from the voucher vendor in response to an operation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providerErrorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProviderErrorCode { get; set; }

        /// <summary>
        /// The error message received from the voucher vendor in response to an operation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providerErrorMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProviderErrorMessage { get; set; }

        /// <summary>
        /// A free form detailed description of a particular failure condition may optionally be supplied
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detailMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object DetailMessage { get; set; }

    }

    /// <summary>
    /// A collection of parameters required to reliably reproduce the hashed value (excluding the actual PIN value).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HashedPinParameters
    {
        /// <summary>
        /// The name of the hashing algorithm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string Name { get; set; }

    }

    /// <summary>
    /// Originating, acquiring, processing, or receiving institution details
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Institution
    {
        /// <summary>
        /// The institution's ID. API implementations should take care to set this field as appropriate for the implementation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The institutions's name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Name { get; set; }

    }

    /// <summary>
    /// An amount object only containing value and currency, and optionally an indicator of DEBIT/CREDIT
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LedgerAmount
    {
        /// <summary>
        /// Amount in minor denomination, e.g. R799.95 is encoded as 79995
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        public long Amount { get; set; }

        /// <summary>
        /// Three digit currency number from ISO 4217, e.g. South African Rand is encoded as 710
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{3}")]
        public string Currency { get; set; }

        /// <summary>
        /// Indicates whether this amount is a debit or a credit. Only required when the amount can be either a debit or a credit
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ledgerIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LedgerAmountLedgerIndicator? LedgerIndicator { get; set; }

    }

    /// <summary>
    /// Model for payments made using loyalty programme cards
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LoyaltyCardPayment : PaymentMethod
    {
        /// <summary>
        /// Primary account number of the loyalty programme card used to make a payment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cardNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{16}")]
        public string CardNumber { get; set; }

    }

    /// <summary>
    /// Merchant related data. Must be included if available
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Merchant
    {
        /// <summary>
        /// The assigned four digit merchant category code
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchantType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{4}")]
        public string MerchantType { get; set; }

        /// <summary>
        /// The assigned merchant identifier. Also known as card acceptor id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchantId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(15, MinimumLength = 15)]
        public string MerchantId { get; set; }

        /// <summary>
        /// The name of a merchant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchantName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public MerchantName MerchantName { get; set; } = new MerchantName();

    }

    /// <summary>
    /// A container object representing the Merchant Name and Location
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MerchantName
    {
        /// <summary>
        /// The merchant or trading as name associated with the merchant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(23)]
        public string Name { get; set; }

        /// <summary>
        /// The city where the merchant is located
        /// </summary>
        [Newtonsoft.Json.JsonProperty("city", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(13)]
        public string City { get; set; }

        /// <summary>
        /// The state or region where the merchant is located
        /// </summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(2)]
        public string Region { get; set; }

        /// <summary>
        /// The country where the merchant is located
        /// </summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(2)]
        public string Country { get; set; }

    }

    /// <summary>
    /// The Originator object encapsulates data relating to the originator of the transaction
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Originator
    {
        /// <summary>
        /// The institution originating the request, as issued by Electrum
        /// </summary>
        [Newtonsoft.Json.JsonProperty("institution", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Institution { get; set; } = new Institution();

        /// <summary>
        /// The ID that uniquely identifies each device or system in an originator's institution capable of sending requests. Required for transactions initiated from physical card entry or point-of-sale devices
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminalId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(8, MinimumLength = 8)]
        public string TerminalId { get; set; }

        /// <summary>
        /// Merchant data. Required if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchant", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Merchant Merchant { get; set; } = new Merchant();

        /// <summary>
        /// The ID that uniquely identifies the person operating the terminal specified by the terminalId field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operatorId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(30)]
        public string OperatorId { get; set; }

        /// <summary>
        /// The ID that uniquely identifies the originator's channel that this transaction was received through.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("channelId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(50)]
        public string ChannelId { get; set; }

    }

    /// <summary>
    /// Base model for all payment types
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("AccountPayment", typeof(AccountPayment))]
    [JsonInheritanceAttribute("An32TokenPayment", typeof(An32TokenPayment))]
    [JsonInheritanceAttribute("CardPayment", typeof(CardPayment))]
    [JsonInheritanceAttribute("LoyaltyCardPayment", typeof(LoyaltyCardPayment))]
    [JsonInheritanceAttribute("QrPayment", typeof(QrPayment))]
    [JsonInheritanceAttribute("RewardPayment", typeof(RewardPayment))]
    [JsonInheritanceAttribute("WalletPayment", typeof(WalletPayment))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PaymentMethod
    {
        /// <summary>
        /// The specific method of payment used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Ledger amount of the payment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount Amount { get; set; }

        /// <summary>
        /// The institution which is responsible for managing this payment method (e.g. the card issuer, the wallet provider, the token provider etc.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Issuer { get; set; }

        /// <summary>
        /// The PIN associated with this payment method. Various PIN formats are supported (clear, encrypted, hashed etc.). NOTE: A pin is not expected in a response and will not be translated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pin Pin { get; set; }

        /// <summary>
        /// An alternative identifier for the customer's source of funds. Acts as a stand in for the customer identifier. E.g. a customer's MSISDN or email address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Proxy { get; set; }

        /// <summary>
        /// An enumerated value describing the type of value used as the proxy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxyType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentMethodProxyType? ProxyType { get; set; }

    }

    /// <summary>
    /// Base model for capturing either a clear PIN or encrypted PIN
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("PinClear", typeof(PinClear))]
    [JsonInheritanceAttribute("PinEncrypted", typeof(PinEncrypted))]
    [JsonInheritanceAttribute("PinHashed", typeof(PinHashed))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Pin
    {

    }

    /// <summary>
    /// A clear PIN required to authorise a transaction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PinClear : Pin
    {
        /// <summary>
        /// A clear PIN
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@".{0,20}")]
        public string Pin { get; set; }

    }

    /// <summary>
    /// A PIN required to authorise a transaction. EncryptionParameters should be provided where the service will be performing operations on the encrypted PIN, such as PIN translation. Only the PIN block need be provided where the service is expected to forward it to a third party, where the calling client and said third party have agreed upon encryption parameters beforehand.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PinEncrypted : Pin
    {
        /// <summary>
        /// Hexadecimal string representing the encrypted PIN to be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinBlock", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[a-fA-F0-9]{16}")]
        public string PinBlock { get; set; }

        /// <summary>
        /// Parameters pertaining to the generation of the pinBlock. Required if the service is to perform any operations on the encrypted PIN, such as PIN translation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptionParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptionParameters EncryptionParameters { get; set; }

    }

    /// <summary>
    /// A PIN, required to authorise a transaction, which has been hashed according to some hashing algorithm.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PinHashed : Pin
    {
        /// <summary>
        /// A hashed PIN expressed as an ASCII string of hexadecimal values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9,A-F]{1,512}")]
        public string Hash { get; set; }

        /// <summary>
        /// Parameters that describe the hashing algorithm used to hash the PIN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hashedPinParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HashedPinParameters HashedPinParameters { get; set; }

    }

    /// <summary>
    /// Describes how the PAN and PIN were captured by the POS.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PosEntryMode
    {
        /// <summary>
        /// Describes the method by which the PAN was captured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("panEntryMode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PosEntryModePanEntryMode PanEntryMode { get; set; }

        /// <summary>
        /// Describes whether the PIN can be entered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinEntryCapability", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PosEntryModePinEntryCapability PinEntryCapability { get; set; }

    }

    /// <summary>
    /// POS related data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PosInfo
    {
        /// <summary>
        /// Describes the manner in which the POS captured card and PIN data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entryMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosEntryMode EntryMode { get; set; }

        /// <summary>
        /// Describes the circumstances of the transaciton at the POS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posConditionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PosInfoPosConditionCode? PosConditionCode { get; set; }

    }

    /// <summary>
    /// Product related data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Product
    {
        /// <summary>
        /// A vendor determined code identifying the product the voucher should pertain to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("productId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9A-Za-z-]{1,40}")]
        public string ProductId { get; set; }

        /// <summary>
        /// A barcode code identifying the product. This is an alternative identifier for the product but does not supersede the productId.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("barcode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9A-Za-z]{1,13}")]
        public string Barcode { get; set; }

        /// <summary>
        /// The name of the product.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string Name { get; set; }

        /// <summary>
        /// The price of the product, if available. When this value is present alongside values for min- or maxValue, this value should be considered the default value for the product in question.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount Amount { get; set; }

        /// <summary>
        /// The minimum amount for which the product can be purchased, if available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount MinAmount { get; set; }

        /// <summary>
        /// The maximum amount for which the product can be purchased, if available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount MaxAmount { get; set; }

        /// <summary>
        /// The description associated with the relevant product.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(250)]
        public string Description { get; set; }

    }

    /// <summary>
    /// Contains the list of requested products.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProductsLookupResponse
    {
        /// <summary>
        /// The list of products.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("products", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Product> Products { get; set; }

    }

    /// <summary>
    /// Information about the voucher provision request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProvisionRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisionRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisionRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisionRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// If the voucher identified by the voucher field is not a fixed price product then the amounts field indicates the value of the product referred to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// An array of tenders used to pay for the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; }

        /// <summary>
        /// The voucher that is being requested for provisioning.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Voucher Voucher { get; set; }

        /// <summary>
        /// The product for which the voucher should be provisioned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("product", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Product Product { get; set; }

        /// <summary>
        /// Information about the status of the POS/terminal used in the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

        /// <summary>
        /// Information about the customer purchasing the voucher, if available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// Details of the customer who will receive and make use of the voucher requested. In cases where the customer provisioning the request is doing so on anothers behalf, it may be necessary to capture the relevant personal details of the voucher recipient.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recipient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Recipient { get; set; }

        /// <summary>
        /// An array of payment methods to be used as payment for the transaction. This is used if payment is not tendered at the point of sale, but is effected through one or more calls to third party payment providers as part of the request. A PaymentMethod differs from a Tender in that the former represents payment that still needs to be collected from a third party, whereas the latter represents payment that has already been collected at the point of sale.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paymentMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PaymentMethod> PaymentMethods { get; set; }

    }

    /// <summary>
    /// Information about the voucher provisioned.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProvisionResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisionResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisionResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisionResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// The amounts for which a single use voucher is provisioned for.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// The voucher provisioned if the vendor processed the request successfully.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Voucher Voucher { get; set; } = new Voucher();

        /// <summary>
        /// The product for which the voucher was provisioned. This should be the same as the product in the ProvisionRequest and is echoed back for convenience.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("product", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Product Product { get; set; }

        /// <summary>
        /// Information about the status of the POS/terminal used in the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

        /// <summary>
        /// Details of the customer who will receive and make use of the voucher requested. In cases where the customer provisioning the request is doing so on anothers behalf, it may be necessary to capture the relevant personal details of the voucher recipient.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recipient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Recipient { get; set; }

        /// <summary>
        /// An array of tenders used to pay for the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; }

    }

    /// <summary>
    /// Model for QR-based payments. This payment method should be used when a QR code is presented for payment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QrPayment : PaymentMethod
    {
        /// <summary>
        /// The unique transaction identifier related to this transaction. In QRs styled on the EMVCo specification, the tranId is embedded in sub-Tag 00 of the Electrum MAIT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TranId { get; set; }

        /// <summary>
        /// A payment token received from the Partner.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partnerPaymentToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PartnerPaymentToken { get; set; }

    }

    /// <summary>
    /// A description of a request to redeem a voucher. This object supports requests for redemptions against amounts different to the value for which the voucher was provisioned.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RedemptionRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedemptionRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedemptionRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedemptionRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// The voucher to be redeemed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Voucher Voucher { get; set; } = new Voucher();

        /// <summary>
        /// Indicates the amount for which the voucher is to be redeemed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// Information about the status of the POS/terminal used in the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

    }

    /// <summary>
    /// Information about the voucher redemption outcome.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RedemptionResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedemptionResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedemptionResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RedemptionResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Describes the voucher provisioned by the vendor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Voucher Voucher { get; set; }

        /// <summary>
        /// Amounts which make up the transaction. Absent amounts have zero value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// Information about the status of the POS/terminal used in the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

    }

    /// <summary>
    /// A description of a request to refund a voucher. This object supports requests for refunds for amounts different to the value for which the voucher was originally redeemed. Refunds are predicated on some prior redemption which may be referenced using a variety of mechanisms: the voucher used (if a voucher may only ever be used once), the redemption's message ID (which links to a specific redemption if a voucher may be re-issued by a voucher vendor), or the receiver's transaction reference for the redemption (most readily identifies the specific redemption to the receiver).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RefundRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Indicates the amount for which the voucher should be refunded in the requestAmount field. If requestAmount is not populated then a full refund is to be assumed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// The voucher to be refunded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Voucher Voucher { get; set; } = new Voucher();

        /// <summary>
        /// Carries the value of the `id` field of the RedemptionRequest which is being refunded. Use of this field is encouraged if the refund request is submitted to the same system which processed the original redemption.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redemptionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RedemptionId { get; set; }

        /// <summary>
        /// Carries the value of the receiver's transaction reference for the original redemption. Use of this field is specifically encouraged if: The voucher alone is not enough to uniquely identify the redemption to be refunded or the refund is processed by any system which did not process the original redemption. Use of this field is generally encouraged as it provides the receiver (who ultimately processed the redemption) with their specific transaction reference for the redemption. This may aid their processing of the refund.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiverTransactionRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReceiverTransactionRef { get; set; }

        /// <summary>
        /// Information about the status of the POS/terminal used in the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

    }

    /// <summary>
    /// Information about the voucher redemption outcome.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RefundResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Indicates the amount for which the voucher was refunded. 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// The voucher that was refunded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Voucher Voucher { get; set; }

        /// <summary>
        /// Information about the status of the POS/terminal used in the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

    }

    /// <summary>
    /// Model for reward-based payments. This payment method should be used when the payment is offset using a reward programme
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RewardPayment : PaymentMethod
    {
        /// <summary>
        /// A code used to recognise the reward programme
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rewardCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string RewardCode { get; set; }

    }

    /// <summary>
    /// Data that may be printed on the customer slip for information purposes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SlipData
    {
        /// <summary>
        /// An array of text lines and optional formatting to be printed on the customer slip.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageLines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SlipLine> MessageLines { get; set; }

        /// <summary>
        /// The width of the slip in normal (unformatted) characters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipWidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SlipWidth { get; set; }

        /// <summary>
        /// An identifier that is printed on the customer slip and uniquely identifies the payment on the service provider's system. This value is used by the customer to request a refund when the service supports this function, and it is thus important that this number is unique.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuerReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z0-9]{1,40}")]
        public string IssuerReference { get; set; }

    }

    /// <summary>
    /// A line of text to be printed on the till slip
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SlipLine
    {
        /// <summary>
        /// Barcode information for this line
        /// </summary>
        [Newtonsoft.Json.JsonProperty("barcode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Barcode Barcode { get; set; }

        /// <summary>
        /// Text contained on the line
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Text { get; set; }

        /// <summary>
        /// Scale factor for font width. Assume 1.0 (i.e. normal size) if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontWidthScaleFactor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FontWidthScaleFactor { get; set; }

        /// <summary>
        /// Scale factor for font height. Assume 1.0 (i.e. normal size) if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontHeightScaleFactor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FontHeightScaleFactor { get; set; }

        /// <summary>
        /// Denotes a solid line on the slip. Assume false if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("line", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Line { get; set; } = false;

        /// <summary>
        /// Indicates the slip should be cut at this line. Assume false if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cut { get; set; } = false;

    }

    /// <summary>
    /// Details of the Tender used by a customer towards a payment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Tender
    {
        /// <summary>
        /// The type of account
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TenderAccountType? AccountType { get; set; }

        /// <summary>
        /// The tendered amount
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LedgerAmount Amount { get; set; } = new LedgerAmount();

        /// <summary>
        /// A PCI compliant masked card number, with at least the first 6 digits in the clear. Only applicable to card based transactions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cardNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{6}[0-9*]{0,13}")]
        public string CardNumber { get; set; }

        /// <summary>
        /// A free text reference
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Reference { get; set; }

        /// <summary>
        /// The type of tender used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenderType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TenderType TenderType { get; set; }

    }

    /// <summary>
    /// An advice that notifies of the successful completion of a transaction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TenderAdvice
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// An array of tenders used to pay for the transaction
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; } = new System.Collections.ObjectModel.Collection<Tender>();

    }

    /// <summary>
    /// An identifier assigned by an entity which process the message. Identifiers are keyed by institution ID thereby enabling any institution to recall a transaction within the entity's own system using the entity's own identifier. Entities must not alter the identifier set by another entity. Once an identifier has been set by an entity, all other entities must send that identifier in subsequent messages.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThirdPartyIdentifier
    {
        /// <summary>
        /// The entity's institution ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("institutionId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InstitutionId { get; set; }

        /// <summary>
        /// The identifier assigned to this transaction by the institution represented in institutionId. This value should be unique within the institution's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TransactionIdentifier { get; set; }

    }

    /// <summary>
    /// Data used to facilitate and communicate the result of 3-D Secure cardholder authentication.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "version")]
    [JsonInheritanceAttribute("ThreeDSecureDataV1", typeof(ThreeDSecureDataV1))]
    [JsonInheritanceAttribute("ThreeDSecureDataV2", typeof(ThreeDSecureDataV2))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThreeDSecureData
    {
        /// <summary>
        /// A 20-byte value that has been Base64 encoded. This value is provided by the Access Control Server as a proof of authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthenticationValue { get; set; }

        /// <summary>
        /// Authentication outcome set by the Access Control Server or Issuer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cardHolderAuthVerificationResult", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThreeDSecureDataCardHolderAuthVerificationResult? CardHolderAuthVerificationResult { get; set; }

        /// <summary>
        /// Electronic Commerce Indicator. This is Payment System-specific value provided by the Access Control Server to indicate the results of the attempt to authenticate the Cardholder.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eci", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThreeDSecureDataEci? Eci { get; set; }

        /// <summary>
        /// Indicates whether a transaction qualifies as an authenticated transaction or account verification. The values and their meanings are as follows: 
        /// <br/>Y = Authentication Verification Successful.
        /// <br/> N = Not Authenticated /Account Not Verified; Transaction denied.
        /// <br/> U = Authentication/ Account Verification Could Not Be Performed; Technical or other problem.
        /// <br/> A = Attempts Processing Performed; Not Authenticated/ Verified, but a proof of attempted authentication/verification is provided.
        /// <br/> C = Challenge Required; Additional authentication is required using the CReq/CRes 
        /// <br/> D = Challenge Required; Decoupled Authentication confirmed. 
        /// <br/> R = Authentication/ Account Verification Rejected; Issuer is rejecting authentication/verification and request that authorisation not be attempted.
        /// <br/> I = Informational Only; 3DS Requestor challenge preference acknowledged.
        /// <br/> S = Challenge using SPC 
        /// <br/> 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThreeDSecureDataTransactionStatus? TransactionStatus { get; set; }

    }

    /// <summary>
    /// 3-D Secure data in which the transaction identifier takes the format of a byte string.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThreeDSecureDataV1 : ThreeDSecureData
    {
        /// <summary>
        /// A 20-byte base 64 encoded string assigned by the 3DS Server to identify a single transaction. This ID can be used to prevent transaction replay.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TransactionId { get; set; }

    }

    /// <summary>
    /// 3-D Secure data in which the transaction identifier takes the format of a UUID.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThreeDSecureDataV2 : ThreeDSecureData
    {
        /// <summary>
        /// A UUID assigned by the 3DS Server to identify a single transaction. This ID can be used to prevent transaction replay. This is based on version 2 the EMVCo 3-D Secure specification.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? TransactionId { get; set; }

    }

    /// <summary>
    /// A label assigned to a transaction by the entity processing the transaction. Labels are used for grouping or discovering transactions after transaction processing. Note that no transaction processing decision is made based on transaction labels.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransactionLabel
    {
        /// <summary>
        /// Label name that indicates the type and intended use of the transaction label. The meaning of label names must be agreed upon by the parties involved in transaction processing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-zA-Z0-9_]{1,100}$")]
        public string Name { get; set; }

        /// <summary>
        /// The value assigned to the transaction label.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-zA-Z0-9 _-]{1,100}$")]
        public string Value { get; set; }

    }

    /// <summary>
    /// Specifically describes the voucher provisioned by the vendor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Voucher
    {
        /// <summary>
        /// The vouchers code used by the customer to redeem the voucher. This must be present in ProvisionResponse, RedemptionRequest and RefundRequest messages. This may be present in a ProvisionRequest if the voucher vendor allows the client to set the voucher code. It is recommended this field not be populated in other instances as it may be considered sensitive data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Code { get; set; }

        /// <summary>
        /// The date and time at which the voucher expires. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiryDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpiryDate { get; set; }

        /// <summary>
        /// An array of free text lines which provide the customer with information on how to redeem the voucher. These are intended to be printed on a customer's receipt slip.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("redeemInstructions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> RedeemInstructions { get; set; }

        /// <summary>
        /// The voucher's serial number. This can be used to identify the voucher in the vendor's system but cannot be used to redeem the voucher.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serialNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string SerialNumber { get; set; }

        /// <summary>
        /// A secret value which is required to be provided by a customer when redeeming the voucher using the code. Use of a PIN in addition to the voucher code adds security to the voucher redemption process.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pin Pin { get; set; }

    }

    /// <summary>
    /// Information about a voucher such as its expiry date, its value and which entity the voucher belongs to.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VoucherLookupResponse
    {
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

        /// <summary>
        /// Information about who the request was routed to for processing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which issued the voucher.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// The amounts for which the single use voucher is provisioned for. If available, the monetary value of the voucher should be specified as a CREDIT amount in the approvedAmount field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// Available details about the voucher.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("voucher", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Voucher Voucher { get; set; } = new Voucher();

        /// <summary>
        /// The product for which the voucher was provisioned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("product", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Product Product { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; }

        /// <summary>
        /// A reference set by the upstream entity that processed the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

    }

    /// <summary>
    /// Model for mobile wallet payments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WalletPayment : PaymentMethod
    {
        /// <summary>
        /// The unique identifier of the wallet account making the payment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("walletId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string WalletId { get; set; }

        /// <summary>
        /// The pocket associated with this wallet from which the payment is to be made. Used to determine where to make a payment from when a wallet is split into different sections. When not provided, payment will be directly from the wallet and not a subsection of the wallet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("walletPocket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WalletPocket WalletPocket { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WalletPocket
    {
        /// <summary>
        /// The name given to this wallet pocket.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pocketName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PocketName { get; set; }

        /// <summary>
        /// A programmatic ID that can be used to identify this pocket when the name is not enough
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pocketId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PocketId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum BasicReversalReversalReason
    {

        [System.Runtime.Serialization.EnumMember(Value = @"TIMEOUT")]
        TIMEOUT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CANCELLED")]
        CANCELLED = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RESPONSE_NOT_FINAL")]
        RESPONSE_NOT_FINAL = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EncryptionParametersPinBlockFormat
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_0")]
        ISO_9564_FORMAT_0 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_1")]
        ISO_9564_FORMAT_1 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_3")]
        ISO_9564_FORMAT_3 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_4")]
        ISO_9564_FORMAT_4 = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ErrorDetailErrorType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DUPLICATE_RECORD")]
        DUPLICATE_RECORD = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FORMAT_ERROR")]
        FORMAT_ERROR = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"FUNCTION_NOT_SUPPORTED")]
        FUNCTION_NOT_SUPPORTED = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ERROR")]
        GENERAL_ERROR = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_AMOUNT")]
        INVALID_AMOUNT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ROUTING_ERROR")]
        ROUTING_ERROR = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"TRANSACTION_NOT_SUPPORTED")]
        TRANSACTION_NOT_SUPPORTED = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"UNABLE_TO_LOCATE_RECORD")]
        UNABLE_TO_LOCATE_RECORD = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"UPSTREAM_UNAVAILABLE")]
        UPSTREAM_UNAVAILABLE = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_ALREADY_REDEEMED")]
        VOUCHER_ALREADY_REDEEMED = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_ALREADY_PROVISIONED")]
        VOUCHER_ALREADY_PROVISIONED = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_ALREADY_CONFIRMED")]
        VOUCHER_ALREADY_CONFIRMED = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_ALREADY_REVERSED")]
        VOUCHER_ALREADY_REVERSED = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_ALREADY_REFUNDED")]
        VOUCHER_ALREADY_REFUNDED = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_NOT_REFUNDED")]
        VOUCHER_NOT_REFUNDED = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_NOT_REDEEMABLE")]
        VOUCHER_NOT_REDEEMABLE = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_NOT_REDEEMED")]
        VOUCHER_NOT_REDEEMED = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"VOUCHER_STATUS_UNKNOWN")]
        VOUCHER_STATUS_UNKNOWN = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"REDEMPTION_ALREADY_CONFIRMED")]
        REDEMPTION_ALREADY_CONFIRMED = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"REDEMPTION_NOT_CONFIRMED")]
        REDEMPTION_NOT_CONFIRMED = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"REDEMPTION_ALREADY_REVERSED")]
        REDEMPTION_ALREADY_REVERSED = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"REFUND_ALREADY_CONFIRMED")]
        REFUND_ALREADY_CONFIRMED = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"REFUND_ALREADY_REVERSED")]
        REFUND_ALREADY_REVERSED = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_MERCHANT")]
        INVALID_MERCHANT = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_VOUCHER")]
        INVALID_VOUCHER = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_ERROR")]
        AUTHENTICATION_ERROR = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"INSUFFICIENT_AMOUNT")]
        INSUFFICIENT_AMOUNT = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"DO_NOT_HONOUR")]
        DO_NOT_HONOUR = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"OUT_OF_STOCK")]
        OUT_OF_STOCK = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_PRODUCT")]
        INVALID_PRODUCT = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"INSUFFICIENT_FUNDS")]
        INSUFFICIENT_FUNDS = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_ACCOUNT")]
        INVALID_ACCOUNT = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"TRANSACTION_DECLINED")]
        TRANSACTION_DECLINED = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"LIMIT_EXCEEDED")]
        LIMIT_EXCEEDED = 33,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum LedgerAmountLedgerIndicator
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT")]
        DEBIT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentMethodProxyType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"MSISDN")]
        MSISDN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EMAIL")]
        EMAIL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PosEntryModePanEntryMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MANUAL")]
        MANUAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"MAGSTRIPE_NO_CVV")]
        MAGSTRIPE_NO_CVV = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"BARCODE")]
        BARCODE = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"OCR")]
        OCR = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ICC_CVV")]
        ICC_CVV = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"CONTACTLESS_ICC")]
        CONTACTLESS_ICC = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"MAGSTRIPE_CVV")]
        MAGSTRIPE_CVV = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"CONTACTLESS_MAGSTRIPE")]
        CONTACTLESS_MAGSTRIPE = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"ICC_NO_CVV")]
        ICC_NO_CVV = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"ORIG_MODE")]
        ORIG_MODE = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"FALLBACK")]
        FALLBACK = 11,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PosEntryModePinEntryCapability
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CAN_ACCEPT")]
        CAN_ACCEPT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CANNOT_ACCEPT")]
        CANNOT_ACCEPT = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PosInfoPosConditionCode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NORMAL_PRESENTMENT")]
        NORMAL_PRESENTMENT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_NOT_PRESENT")]
        CUSTOMER_NOT_PRESENT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_PRESENT_AND_CARD_NOT_PRESENT")]
        CUSTOMER_PRESENT_AND_CARD_NOT_PRESENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_IDENTITY_VERIFIED")]
        CUSTOMER_IDENTITY_VERIFIED = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC_UTILITY_TERMINAL")]
        PUBLIC_UTILITY_TERMINAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_TERMINAL")]
        CUSTOMER_TERMINAL = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"MANUAL_REVERSAL")]
        MANUAL_REVERSAL = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"UNATTENDED_TERMINAL_AND_CARD_CAN_BE_RETAINED")]
        UNATTENDED_TERMINAL_AND_CARD_CAN_BE_RETAINED = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"UNATTENDED_TERMINAL_AND_CARD_CANNOT_BE_RETAINED")]
        UNATTENDED_TERMINAL_AND_CARD_CANNOT_BE_RETAINED = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisionRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisionRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisionRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisionResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisionResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisionResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RedemptionRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RedemptionRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RedemptionRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RedemptionResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RedemptionResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RedemptionResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TenderAccountType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TenderType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CASH")]
        CASH = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_CARD")]
        CREDIT_CARD = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_CARD")]
        DEBIT_CARD = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"WALLET")]
        WALLET = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ROUNDING")]
        ROUNDING = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"LOYALTY_CARD")]
        LOYALTY_CARD = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"OTHER")]
        OTHER = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"REWARD")]
        REWARD = 9,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThreeDSecureDataCardHolderAuthVerificationResult
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_PASSED")]
        CAVV_VALIDATION_PASSED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_FAILED_ISSUER_SYSTEM_ERROR")]
        CAVV_VALIDATION_FAILED_ISSUER_SYSTEM_ERROR = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_FAILED_ISSUER_ATTEMPT_INCOMPLETE")]
        CAVV_VALIDATION_FAILED_ISSUER_ATTEMPT_INCOMPLETE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_NOT_VALIDATED")]
        CAVV_NOT_VALIDATED = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_NOT_VALIDATED_INVALID_DATA")]
        CAVV_NOT_VALIDATED_INVALID_DATA = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_FAILED")]
        CAVV_VALIDATION_FAILED = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThreeDSecureDataEci
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_00")]
        AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_00 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ENABLED_01")]
        AUTHENTICATION_NOT_ENABLED_01 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_SUCCESSFUL_02")]
        AUTHENTICATION_SUCCESSFUL_02 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_SUCCESSFUL_05")]
        AUTHENTICATION_SUCCESSFUL_05 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ENABLED_06")]
        AUTHENTICATION_NOT_ENABLED_06 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_07")]
        AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_07 = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThreeDSecureDataTransactionStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Y")]
        Y = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"N")]
        N = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"U")]
        U = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"A")]
        A = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"C")]
        C = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"D")]
        D = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"R")]
        R = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"I")]
        I = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"S")]
        S = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple = true)]
    internal class JsonInheritanceAttribute : System.Attribute
    {
        public JsonInheritanceAttribute(string key, System.Type type)
        {
            Key = key;
            Type = type;
        }

        public string Key { get; }

        public System.Type Type { get; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public class JsonInheritanceConverter : Newtonsoft.Json.JsonConverter
    {
        internal static readonly string DefaultDiscriminatorName = "discriminator";

        private readonly string _discriminatorName;

        [System.ThreadStatic]
        private static bool _isReading;

        [System.ThreadStatic]
        private static bool _isWriting;

        public JsonInheritanceConverter()
        {
            _discriminatorName = DefaultDiscriminatorName;
        }

        public JsonInheritanceConverter(string discriminatorName)
        {
            _discriminatorName = discriminatorName;
        }

        public string DiscriminatorName { get { return _discriminatorName; } }

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer)
        {
            try
            {
                _isWriting = true;

                var jObject = Newtonsoft.Json.Linq.JObject.FromObject(value, serializer);
                jObject.AddFirst(new Newtonsoft.Json.Linq.JProperty(_discriminatorName, GetSubtypeDiscriminator(value.GetType())));
                writer.WriteToken(jObject.CreateReader());
            }
            finally
            {
                _isWriting = false;
            }
        }

        public override bool CanWrite
        {
            get
            {
                if (_isWriting)
                {
                    _isWriting = false;
                    return false;
                }
                return true;
            }
        }

        public override bool CanRead
        {
            get
            {
                if (_isReading)
                {
                    _isReading = false;
                    return false;
                }
                return true;
            }
        }

        public override bool CanConvert(System.Type objectType)
        {
            return true;
        }

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            var jObject = serializer.Deserialize<Newtonsoft.Json.Linq.JObject>(reader);
            if (jObject == null)
                return null;

            var discriminatorValue = jObject.GetValue(_discriminatorName);
            var discriminator = discriminatorValue != null ? Newtonsoft.Json.Linq.Extensions.Value<string>(discriminatorValue) : null;
            var subtype = GetObjectSubtype(objectType, discriminator);

            var objectContract = serializer.ContractResolver.ResolveContract(subtype) as Newtonsoft.Json.Serialization.JsonObjectContract;
            if (objectContract == null || System.Linq.Enumerable.All(objectContract.Properties, p => p.PropertyName != _discriminatorName))
            {
                jObject.Remove(_discriminatorName);
            }

            try
            {
                _isReading = true;
                return serializer.Deserialize(jObject.CreateReader(), subtype);
            }
            finally
            {
                _isReading = false;
            }
        }

        private System.Type GetObjectSubtype(System.Type objectType, string discriminator)
        {
            foreach (var attribute in System.Reflection.CustomAttributeExtensions.GetCustomAttributes<JsonInheritanceAttribute>(System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType), true))
            {
                if (attribute.Key == discriminator)
                    return attribute.Type;
            }

            return objectType;
        }

        private string GetSubtypeDiscriminator(System.Type objectType)
        {
            foreach (var attribute in System.Reflection.CustomAttributeExtensions.GetCustomAttributes<JsonInheritanceAttribute>(System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType), true))
            {
                if (attribute.Type == objectType)
                    return attribute.Key;
            }

            return objectType.Name;
        }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016
#pragma warning restore 8603