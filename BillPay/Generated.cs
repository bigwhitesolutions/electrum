//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace Electrum.BillPay
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Client 
    {
        private string _baseUrl = "https://billpay-test-server.herokuapp.com/billpay/v4";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public Client(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Basic policy info request
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request</param>
        /// <param name="body">A policy lookup request</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PolicyLookupResponse> AccountLookupsPolicyAsync(string requestId, PolicyLookupRequest body)
        {
            return AccountLookupsPolicyAsync(requestId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Basic policy info request
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request</param>
        /// <param name="body">A policy lookup request</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PolicyLookupResponse> AccountLookupsPolicyAsync(string requestId, PolicyLookupRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (requestId == null)
                throw new System.ArgumentNullException("requestId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accountLookups/policy/{requestId}");
            urlBuilder_.Replace("{requestId}", System.Uri.EscapeDataString(ConvertToString(requestId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PolicyLookupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 501)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not implemented", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Basic traffic fine info request
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request</param>
        /// <param name="body">A traffic fine lookup request</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<TrafficFineLookupResponse> AccountLookupsTrafficAsync(string requestId, TrafficFineLookupRequest body)
        {
            return AccountLookupsTrafficAsync(requestId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Basic traffic fine info request
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request</param>
        /// <param name="body">A traffic fine lookup request</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TrafficFineLookupResponse> AccountLookupsTrafficAsync(string requestId, TrafficFineLookupRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (requestId == null)
                throw new System.ArgumentNullException("requestId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accountLookups/traffic/{requestId}");
            urlBuilder_.Replace("{requestId}", System.Uri.EscapeDataString(ConvertToString(requestId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TrafficFineLookupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 501)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not implemented", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Basic account information request
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request</param>
        /// <param name="body">An account lookup request</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AccountLookupResponse> AccountLookupsAsync(string requestId, AccountLookupRequest body)
        {
            return AccountLookupsAsync(requestId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Basic account information request
        /// </summary>
        /// <param name="requestId">The randomly generated UUID of this request</param>
        /// <param name="body">An account lookup request</param>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AccountLookupResponse> AccountLookupsAsync(string requestId, AccountLookupRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (requestId == null)
                throw new System.ArgumentNullException("requestId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accountLookups/{requestId}");
            urlBuilder_.Replace("{requestId}", System.Uri.EscapeDataString(ConvertToString(requestId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AccountLookupResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 501)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not implemented", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Request the list of managed billers
        /// </summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BillerListResponse> BillersAsync()
        {
            return BillersAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request the list of managed billers
        /// </summary>
        /// <returns>Success</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BillerListResponse> BillersAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/billers");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BillerListResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 501)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not implemented", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initiate a policy payment transaction
        /// </summary>
        /// <param name="paymentId">The randomly generated UUID of this request</param>
        /// <param name="body">A policy payment request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PolicyPaymentResponse> PaymentsPolicyAsync(string paymentId, PolicyPaymentRequest body)
        {
            return PaymentsPolicyAsync(paymentId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiate a policy payment transaction
        /// </summary>
        /// <param name="paymentId">The randomly generated UUID of this request</param>
        /// <param name="body">A policy payment request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PolicyPaymentResponse> PaymentsPolicyAsync(string paymentId, PolicyPaymentRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/payments/policy/{paymentId}");
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PolicyPaymentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initiate a traffic fine payment transaction
        /// </summary>
        /// <param name="paymentId">The randomly generated UUID of this request</param>
        /// <param name="body">A traffic fine payment request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<TrafficFinePaymentResponse> PaymentsTrafficAsync(string paymentId, TrafficFinePaymentRequest body)
        {
            return PaymentsTrafficAsync(paymentId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiate a traffic fine payment transaction
        /// </summary>
        /// <param name="paymentId">The randomly generated UUID of this request</param>
        /// <param name="body">A traffic fine payment request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TrafficFinePaymentResponse> PaymentsTrafficAsync(string paymentId, TrafficFinePaymentRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/payments/traffic/{paymentId}");
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TrafficFinePaymentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Initiate a bill payment transaction
        /// </summary>
        /// <param name="paymentId">The randomly generated UUID of this request</param>
        /// <param name="body">A payment request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PaymentResponse> PaymentsAsync(string paymentId, PaymentRequest body)
        {
            return PaymentsAsync(paymentId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Initiate a bill payment transaction
        /// </summary>
        /// <param name="paymentId">The randomly generated UUID of this request</param>
        /// <param name="body">A payment request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PaymentResponse> PaymentsAsync(string paymentId, PaymentRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/payments/{paymentId}");
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PaymentResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Confirm an existing bill payment
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="paymentId">The UUID generated for the original createPayment request</param>
        /// <param name="body">A payment confirmation</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicAdviceResponse> PaymentsConfirmationsAsync(string adviceId, string paymentId, TenderAdvice body)
        {
            return PaymentsConfirmationsAsync(adviceId, paymentId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Confirm an existing bill payment
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="paymentId">The UUID generated for the original createPayment request</param>
        /// <param name="body">A payment confirmation</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicAdviceResponse> PaymentsConfirmationsAsync(string adviceId, string paymentId, TenderAdvice body, System.Threading.CancellationToken cancellationToken)
        {
            if (adviceId == null)
                throw new System.ArgumentNullException("adviceId");

            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/payments/{paymentId}/confirmations/{adviceId}");
            urlBuilder_.Replace("{adviceId}", System.Uri.EscapeDataString(ConvertToString(adviceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdviceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reverse a payment request that failed or timed out
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="paymentId">The UUID generated for the original createPayment request</param>
        /// <param name="body">A payment reversal</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicAdviceResponse> PaymentsReversalsAsync(string adviceId, string paymentId, BasicReversal body)
        {
            return PaymentsReversalsAsync(adviceId, paymentId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reverse a payment request that failed or timed out
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="paymentId">The UUID generated for the original createPayment request</param>
        /// <param name="body">A payment reversal</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicAdviceResponse> PaymentsReversalsAsync(string adviceId, string paymentId, BasicReversal body, System.Threading.CancellationToken cancellationToken)
        {
            if (adviceId == null)
                throw new System.ArgumentNullException("adviceId");

            if (paymentId == null)
                throw new System.ArgumentNullException("paymentId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/payments/{paymentId}/reversals/{adviceId}");
            urlBuilder_.Replace("{adviceId}", System.Uri.EscapeDataString(ConvertToString(adviceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{paymentId}", System.Uri.EscapeDataString(ConvertToString(paymentId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdviceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Creates a refund of previously confirmed payment
        /// </summary>
        /// <param name="refundId">The randomly generated UUID of this request</param>
        /// <param name="body">A refund request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<RefundResponse> RefundsAsync(string refundId, RefundRequest body)
        {
            return RefundsAsync(refundId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a refund of previously confirmed payment
        /// </summary>
        /// <param name="refundId">The randomly generated UUID of this request</param>
        /// <param name="body">A refund request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RefundResponse> RefundsAsync(string refundId, RefundRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (refundId == null)
                throw new System.ArgumentNullException("refundId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/refunds/{refundId}");
            urlBuilder_.Replace("{refundId}", System.Uri.EscapeDataString(ConvertToString(refundId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RefundResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 501)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Not implemented", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Confirm an existing bill payment refund
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="refundId">The UUID generated for the corresponding createRefund request</param>
        /// <param name="body">A refund confirmation</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicAdviceResponse> RefundsConfirmationsAsync(string adviceId, string refundId, BasicAdvice body)
        {
            return RefundsConfirmationsAsync(adviceId, refundId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Confirm an existing bill payment refund
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="refundId">The UUID generated for the corresponding createRefund request</param>
        /// <param name="body">A refund confirmation</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicAdviceResponse> RefundsConfirmationsAsync(string adviceId, string refundId, BasicAdvice body, System.Threading.CancellationToken cancellationToken)
        {
            if (adviceId == null)
                throw new System.ArgumentNullException("adviceId");

            if (refundId == null)
                throw new System.ArgumentNullException("refundId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/refunds/{refundId}/confirmations/{adviceId}");
            urlBuilder_.Replace("{adviceId}", System.Uri.EscapeDataString(ConvertToString(adviceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{refundId}", System.Uri.EscapeDataString(ConvertToString(refundId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdviceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reverse a refund request that failed or timed out
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="refundId">The UUID generated for the corresponding createRefund request</param>
        /// <param name="body">A refund reversal</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BasicAdviceResponse> RefundsReversalsAsync(string adviceId, string refundId, BasicReversal body)
        {
            return RefundsReversalsAsync(adviceId, refundId, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reverse a refund request that failed or timed out
        /// </summary>
        /// <param name="adviceId">The randomly generated UUID of this request</param>
        /// <param name="refundId">The UUID generated for the corresponding createRefund request</param>
        /// <param name="body">A refund reversal</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BasicAdviceResponse> RefundsReversalsAsync(string adviceId, string refundId, BasicReversal body, System.Threading.CancellationToken cancellationToken)
        {
            if (adviceId == null)
                throw new System.ArgumentNullException("adviceId");

            if (refundId == null)
                throw new System.ArgumentNullException("refundId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/refunds/{refundId}/reversals/{adviceId}");
            urlBuilder_.Replace("{adviceId}", System.Uri.EscapeDataString(ConvertToString(adviceId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{refundId}", System.Uri.EscapeDataString(ConvertToString(refundId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BasicAdviceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Bad request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 504)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorDetail>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ErrorDetail>("Gateway Timeout", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Represents the status of a customer account
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Account
    {
        /// <summary>
        /// A reference number identifying the bill payments processor, bill issuer, and customer
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountRef", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string AccountRef { get; set; }

        /// <summary>
        /// The effective date of the current billing period in the format yyyy-MM-dd
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset? DueDate { get; set; }

    }

    /// <summary>
    /// The data required to request account info
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccountLookupRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountLookupRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountLookupRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountLookupRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// A reference number identifying the bill payments processor, bill issuer, and customer
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountRef", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string AccountRef { get; set; }

    }

    /// <summary>
    /// The data resulting from an account lookup request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccountLookupResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountLookupResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountLookupResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountLookupResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The customer account detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Account Account { get; set; } = new Account();

    }

    /// <summary>
    /// Model for an account-to-account payment method
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AccountPayment : PaymentMethod
    {
        /// <summary>
        /// Source AccountId from which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SrcAccountId { get; set; }

        /// <summary>
        /// Source CustomerId from which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcCustomerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SrcCustomerId { get; set; }

        /// <summary>
        /// Destination AccountId to which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestAccountId { get; set; }

        /// <summary>
        /// Destination CustomerId to which this payment will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destCustomerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestCustomerId { get; set; }

    }

    /// <summary>
    /// Amounts which make up the transaction. Absent amounts have zero value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Amounts
    {
        /// <summary>
        /// The transaction amount requested by the customer to be authorised or approved. This is the total amount the customer wishes to pay for a service or virtual product.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount RequestAmount { get; set; }

        /// <summary>
        /// The transaction amount which was approved by the upstream entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("approvedAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount ApprovedAmount { get; set; }

        /// <summary>
        /// Fees charged by the upstream entity for processing the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount FeeAmount { get; set; }

        /// <summary>
        /// The remaining balance on the customer's account.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("balanceAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount BalanceAmount { get; set; }

        /// <summary>
        /// Any additional amounts that are involved in a transaction which don't appropriately fit into the other amount fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalAmounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LedgerAmount> AdditionalAmounts { get; set; }

    }

    /// <summary>
    /// Model for token-based payments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class An32TokenPayment : PaymentMethod
    {
        /// <summary>
        /// 32 character alphanumeric code which identifies a token
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[a-zA-Z0-9]{32}")]
        public string Token { get; set; }

    }

    /// <summary>
    /// Used to indicate barcode information for a slip line.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Barcode
    {
        /// <summary>
        /// Data to be encoded in the barcode
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Data { get; set; }

        /// <summary>
        /// Specifies the encoding used in the barcode
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Encoding { get; set; }

    }

    /// <summary>
    /// The data required in all advice messages
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BasicAdvice
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

    }

    /// <summary>
    /// Basic advice response information.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BasicAdviceResponse
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

    }

    /// <summary>
    /// An advice that notifies of the negative completion of a transaction. This can be either due to customer cancellation, or as a result of receiving a non-final response (or no response) to a request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BasicReversal
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// The reason for the reversal
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reversalReason", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BasicReversalReversalReason ReversalReason { get; set; }

    }

    /// <summary>
    /// Data that may be printed on the customer slip for information purposes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BillSlipData
    {
        /// <summary>
        /// An array of text lines and optional formatting to be printed on the customer slip.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageLines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SlipLine> MessageLines { get; set; }

        /// <summary>
        /// The width of the slip in normal (unformatted) characters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipWidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SlipWidth { get; set; }

        /// <summary>
        /// An identifier that is printed on the customer slip and uniquely identifies the payment on the service provider's system. This value is used by the customer to request a refund when the service supports this function, and it is thus important that this number is unique.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuerReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z0-9]{1,40}")]
        public string IssuerReference { get; set; }

        /// <summary>
        /// The call centre phone number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("phoneNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PhoneNumber { get; set; }

    }

    /// <summary>
    /// Contains the information about the biller
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Biller
    {
        /// <summary>
        /// Institution identifying the biller.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("billerInstitution", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution BillerInstitution { get; set; } = new Institution();

        /// <summary>
        /// List of Categories to which this biller belongs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("categories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Category> Categories { get; set; }

        /// <summary>
        /// Indicates if transactions should be blocked without sending them to the upstream biller. Transactions will be blocked if allowed is set to false, otherwise they will not be blocked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allowed { get; set; } = false;

    }

    /// <summary>
    /// The data resulting from a biller list request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BillerListResponse
    {
        /// <summary>
        /// The billers supported by the catalog hosted on the Electrum system
        /// </summary>
        [Newtonsoft.Json.JsonProperty("billers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Biller> Billers { get; set; }

    }

    /// <summary>
    /// Amounts which make up the transaction. Absent amounts have zero value.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BillpayAmounts
    {
        /// <summary>
        /// The transaction amount requested by the customer to be authorised or approved. This is the total amount the customer wishes to pay for a service or virtual product.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount RequestAmount { get; set; }

        /// <summary>
        /// The transaction amount which was approved by the upstream entity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("approvedAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount ApprovedAmount { get; set; }

        /// <summary>
        /// Fees charged by the upstream entity for processing the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("feeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount FeeAmount { get; set; }

        /// <summary>
        /// The remaining balance on the customer's account.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("balanceAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount BalanceAmount { get; set; }

        /// <summary>
        /// Any additional amounts that are involved in a transaction which don't appropriately fit into the other amount fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("additionalAmounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LedgerAmount> AdditionalAmounts { get; set; }

        /// <summary>
        /// The maximum amount a customer is allowed to pay towards an account, policy or some other payment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxPayableAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount MaxPayableAmount { get; set; }

        /// <summary>
        /// The minimum amount a customer is allowed to pay towards an account, policy or some other payment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minPayableAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount MinPayableAmount { get; set; }

    }

    /// <summary>
    /// Model for card-based payments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CardPayment : PaymentMethod
    {
        [Newtonsoft.Json.JsonProperty("posInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosInfo PosInfo { get; set; }

        /// <summary>
        /// The PIN associated with this card as either a clear PIN or an encrypted PIN in HEX format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pin Pin { get; set; }

        /// <summary>
        /// Primary account number that uniquely identifies this card.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pan", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{1,19}")]
        public string Pan { get; set; }

        /// <summary>
        /// The card expiry date, in YYMM format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiryDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{4}")]
        public string ExpiryDate { get; set; }

        /// <summary>
        /// Data used to facilitate and communicate the result of 3-D Secure cardholder authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("threeDSecureData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ThreeDSecureData ThreeDSecureData { get; set; }

        /// <summary>
        /// The encrypted pin number associated with the card in HEX format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedPin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptedPin EncryptedPin { get; set; }

    }

    /// <summary>
    /// Category to which a bill issuer can belong
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Category
    {
        /// <summary>
        /// Unique identifier for this category
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Id { get; set; }

        /// <summary>
        /// Category name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(100)]
        public string Name { get; set; }

    }

    /// <summary>
    /// A bill payment customer
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Customer
    {
        /// <summary>
        /// The customer's first name(s)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string FirstName { get; set; }

        /// <summary>
        /// The customer's last name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string LastName { get; set; }

        /// <summary>
        /// The customer's address
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(80)]
        public string Address { get; set; }

        /// <summary>
        /// The customer's ID Number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(13)]
        public string IdNumber { get; set; }

        /// <summary>
        /// The customer's contact number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contactNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string ContactNumber { get; set; }

    }

    /// <summary>
    /// A PIN required to authorise a transaction. EncryptionParameters should be provided where the service will be performing operations on the encrypted PIN, such as PIN translation. Only the PIN block need be provided where the service is expected to forward it to a third party, where the calling client and said third party have agreed upon encryption parameters beforehand.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EncryptedPin
    {
        /// <summary>
        /// Hexadecimal string representing the encrypted PIN to be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinBlock", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[a-fA-F0-9]{16}")]
        public string PinBlock { get; set; }

        /// <summary>
        /// Parameters pertaining to the generation of the pinBlock. Required if the service is to perform any operations on the encrypted PIN, such as PIN translation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptionParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptionParameters EncryptionParameters { get; set; }

    }

    /// <summary>
    /// Parameters pertaining to the generation of the PIN block. Required if the service is to perform any operations on the encrypted PIN, such as translation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EncryptionParameters
    {
        /// <summary>
        /// PIN block format that was used when encrypting the PIN. Defaults to ISO_9564_FORMAT_0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinBlockFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EncryptionParametersPinBlockFormat? PinBlockFormat { get; set; } = Electrum.BillPay.EncryptionParametersPinBlockFormat.ISO_9564_FORMAT_0;

        /// <summary>
        /// 12 digit account number used when encrypting the PIN. When account number is a card number (PAN), this is the rightmost 12 digits excluding the check digit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{12}")]
        public string AccountNumber { get; set; }

        /// <summary>
        /// Index of the key under which the PIN block is encrypted. Where keys are exchanged in TR-31 KeyBlock format, this should be set to the key version number field of the key used for encryption. If this field is not populated, the most recently exchanged key will be used. Note that omitting this field may require a higher level of synchronization during automated key exchange in some environments.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyIndex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? KeyIndex { get; set; }

    }

    /// <summary>
    /// Represents the outcome of a completed transaction
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorDetail
    {
        /// <summary>
        /// The type of error that occurred
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ErrorDetailErrorType ErrorType { get; set; }

        /// <summary>
        /// A short description of the error
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorMessage", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string ErrorMessage { get; set; }

        /// <summary>
        /// The type of request being processed when the error occurred. Refer to Release Notes for deprecated values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ErrorDetailRequestType RequestType { get; set; }

        /// <summary>
        /// The UUID of the message for which error occurred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID of the original request message in the case of an error occurring for an advice message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OriginalId { get; set; }

        /// <summary>
        /// A free form detailed description of a particular failure condition may optionally be supplied
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detailMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object DetailMessage { get; set; }

    }

    /// <summary>
    /// A collection of parameters required to reliably reproduce the hashed value (excluding the actual PIN value).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HashedPinParameters
    {
        /// <summary>
        /// The name of the hashing algorithm.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string Name { get; set; }

    }

    /// <summary>
    /// Originating, acquiring, processing, or receiving institution details
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Institution
    {
        /// <summary>
        /// The institution's ID. API implementations should take care to set this field as appropriate for the implementation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The institutions's name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Name { get; set; }

    }

    /// <summary>
    /// An amount object only containing value and currency, and optionally an indicator of DEBIT/CREDIT
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LedgerAmount
    {
        /// <summary>
        /// Amount in minor denomination, e.g. R799.95 is encoded as 79995
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        public long Amount { get; set; }

        /// <summary>
        /// Three digit currency number from ISO 4217, e.g. South African Rand is encoded as 710
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{3}")]
        public string Currency { get; set; }

        /// <summary>
        /// Indicates whether this amount is a debit or a credit. Only required when the amount can be either a debit or a credit
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ledgerIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LedgerAmountLedgerIndicator? LedgerIndicator { get; set; }

    }

    /// <summary>
    /// Model for payments made using loyalty programme cards
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LoyaltyCardPayment : PaymentMethod
    {
        /// <summary>
        /// Primary account number of the loyalty programme card used to make a payment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cardNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{16}")]
        public string CardNumber { get; set; }

    }

    /// <summary>
    /// Merchant related data. Must be included if available
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Merchant
    {
        /// <summary>
        /// The assigned four digit merchant category code
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchantType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{4}")]
        public string MerchantType { get; set; }

        /// <summary>
        /// The assigned merchant identifier. Also known as card acceptor id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchantId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(15, MinimumLength = 15)]
        public string MerchantId { get; set; }

        /// <summary>
        /// The name of a merchant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchantName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public MerchantName MerchantName { get; set; } = new MerchantName();

    }

    /// <summary>
    /// A container object representing the Merchant Name and Location
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MerchantName
    {
        /// <summary>
        /// The merchant or trading as name associated with the merchant
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(23)]
        public string Name { get; set; }

        /// <summary>
        /// The city where the merchant is located
        /// </summary>
        [Newtonsoft.Json.JsonProperty("city", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(13)]
        public string City { get; set; }

        /// <summary>
        /// The state or region where the merchant is located
        /// </summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(2)]
        public string Region { get; set; }

        /// <summary>
        /// The country where the merchant is located
        /// </summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(2)]
        public string Country { get; set; }

    }

    /// <summary>
    /// The Originator object encapsulates data relating to the originator of the transaction
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Originator
    {
        /// <summary>
        /// The institution originating the request, as issued by Electrum
        /// </summary>
        [Newtonsoft.Json.JsonProperty("institution", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Institution { get; set; } = new Institution();

        /// <summary>
        /// The ID that uniquely identifies each device or system in an originator's institution capable of sending requests. Required for transactions initiated from physical card entry or point-of-sale devices
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminalId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(8, MinimumLength = 8)]
        public string TerminalId { get; set; }

        /// <summary>
        /// Merchant data. Required if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("merchant", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Merchant Merchant { get; set; } = new Merchant();

        /// <summary>
        /// The ID that uniquely identifies the person operating the terminal specified by the terminalId field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operatorId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(30)]
        public string OperatorId { get; set; }

        /// <summary>
        /// The ID that uniquely identifies the originator's channel that this transaction was received through.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("channelId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(50)]
        public string ChannelId { get; set; }

    }

    /// <summary>
    /// Base model for all payment types
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("AccountPayment", typeof(AccountPayment))]
    [JsonInheritanceAttribute("An32TokenPayment", typeof(An32TokenPayment))]
    [JsonInheritanceAttribute("CardPayment", typeof(CardPayment))]
    [JsonInheritanceAttribute("LoyaltyCardPayment", typeof(LoyaltyCardPayment))]
    [JsonInheritanceAttribute("QrPayment", typeof(QrPayment))]
    [JsonInheritanceAttribute("RewardPayment", typeof(RewardPayment))]
    [JsonInheritanceAttribute("WalletPayment", typeof(WalletPayment))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PaymentMethod
    {
        /// <summary>
        /// The specific method of payment used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Ledger amount of the payment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LedgerAmount Amount { get; set; }

        /// <summary>
        /// The institution which is responsible for managing this payment method (e.g. the card issuer, the wallet provider, the token provider etc.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Issuer { get; set; }

        /// <summary>
        /// The PIN associated with this payment method. Various PIN formats are supported (clear, encrypted, hashed etc.). NOTE: A pin is not expected in a response and will not be translated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pin Pin { get; set; }

        /// <summary>
        /// An alternative identifier for the customer's source of funds. Acts as a stand in for the customer identifier. E.g. a customer's MSISDN or email address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Proxy { get; set; }

        /// <summary>
        /// An enumerated value describing the type of value used as the proxy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("proxyType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentMethodProxyType? ProxyType { get; set; }

    }

    /// <summary>
    /// Represents a request to perform a payment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PaymentRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// A reference number identifying the bill payments processor, bill issuer, and customer
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountRef", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string AccountRef { get; set; }

        /// <summary>
        /// Contains the payment amount.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Contains the tenders for the payment request if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; }

        /// <summary>
        /// Contains the payment method for the payment request if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paymentMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PaymentMethod> PaymentMethods { get; set; }

    }

    /// <summary>
    /// Represents a response to a payment request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PaymentResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The customer account detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Account Account { get; set; } = new Account();

        /// <summary>
        /// Contains the tenders for the payment response if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; }

        /// <summary>
        /// Contains the payment method for the payment response if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paymentMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PaymentMethod> PaymentMethods { get; set; }

    }

    /// <summary>
    /// Base model for capturing either a clear PIN or encrypted PIN
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "type")]
    [JsonInheritanceAttribute("PinClear", typeof(PinClear))]
    [JsonInheritanceAttribute("PinEncrypted", typeof(PinEncrypted))]
    [JsonInheritanceAttribute("PinHashed", typeof(PinHashed))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Pin
    {

    }

    /// <summary>
    /// A clear PIN required to authorise a transaction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PinClear : Pin
    {
        /// <summary>
        /// A clear PIN
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@".{0,20}")]
        public string Pin { get; set; }

    }

    /// <summary>
    /// A PIN required to authorise a transaction. EncryptionParameters should be provided where the service will be performing operations on the encrypted PIN, such as PIN translation. Only the PIN block need be provided where the service is expected to forward it to a third party, where the calling client and said third party have agreed upon encryption parameters beforehand.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PinEncrypted : Pin
    {
        /// <summary>
        /// Hexadecimal string representing the encrypted PIN to be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinBlock", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[a-fA-F0-9]{16}")]
        public string PinBlock { get; set; }

        /// <summary>
        /// Parameters pertaining to the generation of the pinBlock. Required if the service is to perform any operations on the encrypted PIN, such as PIN translation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptionParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptionParameters EncryptionParameters { get; set; }

    }

    /// <summary>
    /// A PIN, required to authorise a transaction, which has been hashed according to some hashing algorithm.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PinHashed : Pin
    {
        /// <summary>
        /// A hashed PIN expressed as an ASCII string of hexadecimal values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9,A-F]{1,512}")]
        public string Hash { get; set; }

        /// <summary>
        /// Parameters that describe the hashing algorithm used to hash the PIN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hashedPinParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HashedPinParameters HashedPinParameters { get; set; }

    }

    /// <summary>
    /// Represents the status of a customer policy
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Policy
    {
        /// <summary>
        /// A reference number identifying the policy to the processor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policyNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string PolicyNumber { get; set; }

        /// <summary>
        /// The date by which the next policy payment must be made in the format yyyy-MM-dd.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset? DueDate { get; set; }

    }

    /// <summary>
    /// The data required to request policy info
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PolicyLookupRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLookupRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLookupRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLookupRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// A reference number identifying the policy to the service provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policyNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string PolicyNumber { get; set; }

    }

    /// <summary>
    /// The data resulting from a policy lookup request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PolicyLookupResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLookupResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLookupResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyLookupResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The customer policy detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Policy Policy { get; set; } = new Policy();

    }

    /// <summary>
    /// Represents a request to perform a payment of a traffic fine.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PolicyPaymentRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyPaymentRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyPaymentRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyPaymentRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// A reference number identifying the policy to the service provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policyNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string PolicyNumber { get; set; }

        /// <summary>
        /// Contains the payment amount.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Contains the tenders for the payment request if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; }

        /// <summary>
        /// Contains the payment method for the payment request if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paymentMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PaymentMethod> PaymentMethods { get; set; }

    }

    /// <summary>
    /// Represents a response to a policy payment request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PolicyPaymentResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyPaymentResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyPaymentResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PolicyPaymentResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The customer policy detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Policy Policy { get; set; } = new Policy();

    }

    /// <summary>
    /// Describes how the PAN and PIN were captured by the POS.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PosEntryMode
    {
        /// <summary>
        /// Describes the method by which the PAN was captured.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("panEntryMode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PosEntryModePanEntryMode PanEntryMode { get; set; }

        /// <summary>
        /// Describes whether the PIN can be entered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pinEntryCapability", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PosEntryModePinEntryCapability PinEntryCapability { get; set; }

    }

    /// <summary>
    /// POS related data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PosInfo
    {
        /// <summary>
        /// Describes the manner in which the POS captured card and PIN data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entryMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PosEntryMode EntryMode { get; set; }

        /// <summary>
        /// Describes the circumstances of the transaciton at the POS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("posConditionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PosInfoPosConditionCode? PosConditionCode { get; set; }

    }

    /// <summary>
    /// Model for QR-based payments. This payment method should be used when a QR code is presented for payment.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QrPayment : PaymentMethod
    {
        /// <summary>
        /// The unique transaction identifier related to this transaction. In QRs styled on the EMVCo specification, the tranId is embedded in sub-Tag 00 of the Electrum MAIT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TranId { get; set; }

        /// <summary>
        /// A payment token received from the Partner.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partnerPaymentToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PartnerPaymentToken { get; set; }

    }

    /// <summary>
    /// Represents a request to refund a payment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RefundRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// An identifier that is printed on the customer slip and uniquely identifies the payment on the bill issuer's system. This value is used by the customer to request a refund when the service supports this function, and it is thus important that this number is unique
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuerReference", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z0-9]{1,20}")]
        public string IssuerReference { get; set; }

        /// <summary>
        /// The reason for the refund as given by the customer
        /// </summary>
        [Newtonsoft.Json.JsonProperty("refundReason", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string RefundReason { get; set; }

    }

    /// <summary>
    /// Represents a response to a refund request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RefundResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RefundResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The customer account detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("account", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Account Account { get; set; }

        /// <summary>
        /// The customer trafficFine detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trafficFine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TrafficFine TrafficFine { get; set; }

        /// <summary>
        /// The customer policy detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Policy Policy { get; set; }

    }

    /// <summary>
    /// Model for reward-based payments. This payment method should be used when the payment is offset using a reward programme
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RewardPayment : PaymentMethod
    {
        /// <summary>
        /// A code used to recognise the reward programme
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rewardCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string RewardCode { get; set; }

    }

    /// <summary>
    /// Data that may be printed on the customer slip for information purposes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SlipData
    {
        /// <summary>
        /// An array of text lines and optional formatting to be printed on the customer slip.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageLines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SlipLine> MessageLines { get; set; }

        /// <summary>
        /// The width of the slip in normal (unformatted) characters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipWidth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SlipWidth { get; set; }

        /// <summary>
        /// An identifier that is printed on the customer slip and uniquely identifies the payment on the service provider's system. This value is used by the customer to request a refund when the service supports this function, and it is thus important that this number is unique.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issuerReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[A-Z0-9]{1,40}")]
        public string IssuerReference { get; set; }

    }

    /// <summary>
    /// A line of text to be printed on the till slip
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SlipLine
    {
        /// <summary>
        /// Barcode information for this line
        /// </summary>
        [Newtonsoft.Json.JsonProperty("barcode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Barcode Barcode { get; set; }

        /// <summary>
        /// Text contained on the line
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Text { get; set; }

        /// <summary>
        /// Scale factor for font width. Assume 1.0 (i.e. normal size) if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontWidthScaleFactor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FontWidthScaleFactor { get; set; }

        /// <summary>
        /// Scale factor for font height. Assume 1.0 (i.e. normal size) if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fontHeightScaleFactor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FontHeightScaleFactor { get; set; }

        /// <summary>
        /// Denotes a solid line on the slip. Assume false if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("line", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Line { get; set; } = false;

        /// <summary>
        /// Indicates the slip should be cut at this line. Assume false if not present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cut", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cut { get; set; } = false;

    }

    /// <summary>
    /// Details of the Tender used by a customer towards a payment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Tender
    {
        /// <summary>
        /// The type of account
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accountType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TenderAccountType? AccountType { get; set; }

        /// <summary>
        /// The tendered amount
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LedgerAmount Amount { get; set; } = new LedgerAmount();

        /// <summary>
        /// A PCI compliant masked card number, with at least the first 6 digits in the clear. Only applicable to card based transactions
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cardNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"[0-9]{6}[0-9*]{0,13}")]
        public string CardNumber { get; set; }

        /// <summary>
        /// A free text reference
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40)]
        public string Reference { get; set; }

        /// <summary>
        /// The type of tender used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenderType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TenderType TenderType { get; set; }

    }

    /// <summary>
    /// An advice that notifies of the successful completion of a transaction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TenderAdvice
    {
        /// <summary>
        /// The randomly generated UUID identifying this advice, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The UUID identifying the request that this advice relates to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RequestId { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// The unaltered thirdPartyIdentifiers array as supplied in the related BasicResponse message. Required if thirdPartyIdentifiers field was present in the BasicResponse. If no thirdPartyIdentifiers was received in the BasicResponse or no BasicResponse was received then this should be set to the thirdPartyIdentifiers sent in the original request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Communicates the final amount for a transaction in the approvedAmount field. If absent from a reversal then a full reversal is implied (i.e. a final amount of zero). If absent from a confirmation then a full confirmation is implied (i.e. the final amount is the same as the approvedAmount of the  authorisation response). The approvedAmount in an advice message should be less than or equal to the approvedAmount of the authorisation response as stand-in transactions are not currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amounts Amounts { get; set; }

        /// <summary>
        /// An array of tenders used to pay for the transaction
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; } = new System.Collections.ObjectModel.Collection<Tender>();

    }

    /// <summary>
    /// An identifier assigned by an entity which process the message. Identifiers are keyed by institution ID thereby enabling any institution to recall a transaction within the entity's own system using the entity's own identifier. Entities must not alter the identifier set by another entity. Once an identifier has been set by an entity, all other entities must send that identifier in subsequent messages.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThirdPartyIdentifier
    {
        /// <summary>
        /// The entity's institution ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("institutionId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InstitutionId { get; set; }

        /// <summary>
        /// The identifier assigned to this transaction by the institution represented in institutionId. This value should be unique within the institution's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TransactionIdentifier { get; set; }

    }

    /// <summary>
    /// Data used to facilitate and communicate the result of 3-D Secure cardholder authentication.
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(JsonInheritanceConverter), "version")]
    [JsonInheritanceAttribute("ThreeDSecureDataV1", typeof(ThreeDSecureDataV1))]
    [JsonInheritanceAttribute("ThreeDSecureDataV2", typeof(ThreeDSecureDataV2))]
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThreeDSecureData
    {
        /// <summary>
        /// A 20-byte value that has been Base64 encoded. This value is provided by the Access Control Server as a proof of authentication.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthenticationValue { get; set; }

        /// <summary>
        /// Authentication outcome set by the Access Control Server or Issuer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cardHolderAuthVerificationResult", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThreeDSecureDataCardHolderAuthVerificationResult? CardHolderAuthVerificationResult { get; set; }

        /// <summary>
        /// Electronic Commerce Indicator. This is Payment System-specific value provided by the Access Control Server to indicate the results of the attempt to authenticate the Cardholder.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eci", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThreeDSecureDataEci? Eci { get; set; }

        /// <summary>
        /// Indicates whether a transaction qualifies as an authenticated transaction or account verification. The values and their meanings are as follows: 
        /// <br/>Y = Authentication Verification Successful.
        /// <br/> N = Not Authenticated /Account Not Verified; Transaction denied.
        /// <br/> U = Authentication/ Account Verification Could Not Be Performed; Technical or other problem.
        /// <br/> A = Attempts Processing Performed; Not Authenticated/ Verified, but a proof of attempted authentication/verification is provided.
        /// <br/> C = Challenge Required; Additional authentication is required using the CReq/CRes 
        /// <br/> D = Challenge Required; Decoupled Authentication confirmed. 
        /// <br/> R = Authentication/ Account Verification Rejected; Issuer is rejecting authentication/verification and request that authorisation not be attempted.
        /// <br/> I = Informational Only; 3DS Requestor challenge preference acknowledged.
        /// <br/> S = Challenge using SPC 
        /// <br/> 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThreeDSecureDataTransactionStatus? TransactionStatus { get; set; }

    }

    /// <summary>
    /// 3-D Secure data in which the transaction identifier takes the format of a byte string.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThreeDSecureDataV1 : ThreeDSecureData
    {
        /// <summary>
        /// A 20-byte base 64 encoded string assigned by the 3DS Server to identify a single transaction. This ID can be used to prevent transaction replay.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TransactionId { get; set; }

    }

    /// <summary>
    /// 3-D Secure data in which the transaction identifier takes the format of a UUID.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ThreeDSecureDataV2 : ThreeDSecureData
    {
        /// <summary>
        /// A UUID assigned by the 3DS Server to identify a single transaction. This ID can be used to prevent transaction replay. This is based on version 2 the EMVCo 3-D Secure specification.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? TransactionId { get; set; }

    }

    /// <summary>
    /// Represents the status of a traffic fine
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficFine
    {
        /// <summary>
        /// A reference number identifying the traffic fine to the processor's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("noticeNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string NoticeNumber { get; set; }

        /// <summary>
        /// The date by which the traffic fine should be paid in the format yyyy-MM-dd.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dueDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset? DueDate { get; set; }

    }

    /// <summary>
    /// The data required to request traffic fine info
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficFineLookupRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFineLookupRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFineLookupRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFineLookupRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// A reference number identifying the traffic fine to the service provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("noticeNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string NoticeNumber { get; set; }

    }

    /// <summary>
    /// The data resulting from a traffic fine lookup request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficFineLookupResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFineLookupResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFineLookupResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFineLookupResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The traffic fine detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trafficFine", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TrafficFine TrafficFine { get; set; } = new TrafficFine();

    }

    /// <summary>
    /// Represents a request to perform a payment of a traffic fine.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficFinePaymentRequest
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The getBillers operation includes a list of available categories for each biller. This field can be used to associate one of those categories with the request transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selectedCategory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Category SelectedCategory { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlipData SlipData { get; set; }

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFinePaymentRequestTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFinePaymentRequestSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFinePaymentRequestDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// A reference number identifying the traffic fine to the service provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("noticeNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 6)]
        public string NoticeNumber { get; set; }

        /// <summary>
        /// Contains the payment amount.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Contains the tenders for the payment request if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Tender> Tenders { get; set; }

        /// <summary>
        /// Contains the payment method for the payment request if available
        /// </summary>
        [Newtonsoft.Json.JsonProperty("paymentMethods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PaymentMethod> PaymentMethods { get; set; }

    }

    /// <summary>
    /// Represents a response to a payment request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficFinePaymentResponse
    {
        /// <summary>
        /// A list containing labels that can be used to discover this transaction or group it with other transactions sharing labels with the same label name and value. Transaction labels should never be used to make transaction processing decisions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transactionLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TransactionLabel> TransactionLabels { get; set; }

        /// <summary>
        /// The randomly generated UUID identifying this transaction, as defined for a variant 4 UUID in [RFC 4122](https://tools.ietf.org/html/rfc4122)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// The date and time of the message as recorded by the sender. The format shall be as defined for date-time in [RFC 3339 section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6). It is recommended that the optional time-secfrac be included up to millisecond precision
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Time { get; set; }

        /// <summary>
        /// Data relating to the originator of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("originator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Originator Originator { get; set; } = new Originator();

        /// <summary>
        /// Data relating to the sender of Transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Institution Client { get; set; } = new Institution();

        /// <summary>
        /// Data relating to the entity with whom the Merchant will settle the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("settlementEntity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution SettlementEntity { get; set; }

        /// <summary>
        /// Data relating to the entity which ultimately processes the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Institution Receiver { get; set; }

        /// <summary>
        /// An array of identifiers which each identify the transaction within each entity's system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdPartyIdentifiers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ThirdPartyIdentifier> ThirdPartyIdentifiers { get; set; } = new System.Collections.ObjectModel.Collection<ThirdPartyIdentifier>();

        /// <summary>
        /// Text to be printed on the customer receipt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slipData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillSlipData SlipData { get; set; } = new BillSlipData();

        /// <summary>
        /// Used to group multiple transactions which would otherwise be considered independent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("basketRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BasketRef { get; set; }

        /// <summary>
        /// Data relating to the type of transaction taking place (i.e. cash withdrawal, goods and services etc.).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tranType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFinePaymentResponseTranType? TranType { get; set; }

        /// <summary>
        /// This specifies the type of source account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("srcAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFinePaymentResponseSrcAccType? SrcAccType { get; set; }

        /// <summary>
        /// This specifies the type of destination account being used in the transaction (i.e. cheque, savings).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destAccType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TrafficFinePaymentResponseDestAccType? DestAccType { get; set; }

        /// <summary>
        /// The System Trace Audit Number can be used to locate transactions across different systems.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stan { get; set; }

        /// <summary>
        /// This is a reference set by the original source of the transaction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rrn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Rrn { get; set; }

        /// <summary>
        /// Customer detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Customer Customer { get; set; }

        /// <summary>
        /// The message amount details such as account balance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amounts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BillpayAmounts Amounts { get; set; } = new BillpayAmounts();

        /// <summary>
        /// Indicates whether a payment amount may be less than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PartPaymentAllowed { get; set; } = false;

        /// <summary>
        /// Indicates whether a payment amount may be more than the amount due. Defaults to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("overPaymentAllowed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverPaymentAllowed { get; set; } = false;

        /// <summary>
        /// The customer account detail
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trafficFine", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TrafficFine TrafficFine { get; set; } = new TrafficFine();

    }

    /// <summary>
    /// A label assigned to a transaction by the entity processing the transaction. Labels are used for grouping or discovering transactions after transaction processing. Note that no transaction processing decision is made based on transaction labels.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransactionLabel
    {
        /// <summary>
        /// Label name that indicates the type and intended use of the transaction label. The meaning of label names must be agreed upon by the parties involved in transaction processing.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-zA-Z0-9_]{1,100}$")]
        public string Name { get; set; }

        /// <summary>
        /// The value assigned to the transaction label.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-zA-Z0-9 _-]{1,100}$")]
        public string Value { get; set; }

    }

    /// <summary>
    /// Model for mobile wallet payments
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WalletPayment : PaymentMethod
    {
        /// <summary>
        /// The unique identifier of the wallet account making the payment.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("walletId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string WalletId { get; set; }

        /// <summary>
        /// The pocket associated with this wallet from which the payment is to be made. Used to determine where to make a payment from when a wallet is split into different sections. When not provided, payment will be directly from the wallet and not a subsection of the wallet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("walletPocket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WalletPocket WalletPocket { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WalletPocket
    {
        /// <summary>
        /// The name given to this wallet pocket.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pocketName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PocketName { get; set; }

        /// <summary>
        /// A programmatic ID that can be used to identify this pocket when the name is not enough
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pocketId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PocketId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccountLookupRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccountLookupRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccountLookupRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccountLookupResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccountLookupResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccountLookupResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum BasicReversalReversalReason
    {

        [System.Runtime.Serialization.EnumMember(Value = @"TIMEOUT")]
        TIMEOUT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CANCELLED")]
        CANCELLED = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RESPONSE_NOT_FINAL")]
        RESPONSE_NOT_FINAL = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EncryptionParametersPinBlockFormat
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_0")]
        ISO_9564_FORMAT_0 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_1")]
        ISO_9564_FORMAT_1 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_3")]
        ISO_9564_FORMAT_3 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ISO_9564_FORMAT_4")]
        ISO_9564_FORMAT_4 = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ErrorDetailErrorType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DUPLICATE_RECORD")]
        DUPLICATE_RECORD = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FORMAT_ERROR")]
        FORMAT_ERROR = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"FUNCTION_NOT_SUPPORTED")]
        FUNCTION_NOT_SUPPORTED = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ERROR")]
        GENERAL_ERROR = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_AMOUNT")]
        INVALID_AMOUNT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ROUTING_ERROR")]
        ROUTING_ERROR = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"TRANSACTION_NOT_SUPPORTED")]
        TRANSACTION_NOT_SUPPORTED = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"UNABLE_TO_LOCATE_RECORD")]
        UNABLE_TO_LOCATE_RECORD = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN_CUSTOMER_ACCOUNT")]
        UNKNOWN_CUSTOMER_ACCOUNT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"UPSTREAM_UNAVAILABLE")]
        UPSTREAM_UNAVAILABLE = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"ACCOUNT_ALREADY_SETTLED")]
        ACCOUNT_ALREADY_SETTLED = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_PRODUCT")]
        INVALID_PRODUCT = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_MERCHANT")]
        INVALID_MERCHANT = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"RECEIVER_BLACKLISTED")]
        RECEIVER_BLACKLISTED = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"LUHN_CHECK_FAILED")]
        LUHN_CHECK_FAILED = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"BLOCKED_USING_SETTLEMENT_ENTITY")]
        BLOCKED_USING_SETTLEMENT_ENTITY = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"BELOW_MINIMUM_ALLOWED_AMOUNT")]
        BELOW_MINIMUM_ALLOWED_AMOUNT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"ABOVE_MAXIMUM_ALLOWED_AMOUNT")]
        ABOVE_MAXIMUM_ALLOWED_AMOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_ACCOUNT_ERROR")]
        CUSTOMER_ACCOUNT_ERROR = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"DO_NOT_HONOR")]
        DO_NOT_HONOR = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"SYSTEM_MALFUNCTION")]
        SYSTEM_MALFUNCTION = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"TRANSACTION_DECLINED")]
        TRANSACTION_DECLINED = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_ACCOUNT")]
        INVALID_ACCOUNT = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"LIMIT_EXCEEDED")]
        LIMIT_EXCEEDED = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"INSUFFICIENT_FUNDS")]
        INSUFFICIENT_FUNDS = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"OUTCOME_UNKNOWN")]
        OUTCOME_UNKNOWN = 25,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ErrorDetailRequestType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ACCOUNT_LOOKUP_REQUEST")]
        ACCOUNT_LOOKUP_REQUEST = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TRAFFIC_FINE_LOOKUP_REQUEST")]
        TRAFFIC_FINE_LOOKUP_REQUEST = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"POLICY_LOOKUP_REQUEST")]
        POLICY_LOOKUP_REQUEST = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_REQUEST")]
        PAYMENT_REQUEST = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"TRAFFIC_FINE_PAYMENT_REQUEST")]
        TRAFFIC_FINE_PAYMENT_REQUEST = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"POLICY_PAYMENT_REQUEST")]
        POLICY_PAYMENT_REQUEST = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_REVERSAL")]
        PAYMENT_REVERSAL = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"TRAFFIC_FINE_PAYMENT_REVERSAL")]
        TRAFFIC_FINE_PAYMENT_REVERSAL = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_CONFIRMATION")]
        PAYMENT_CONFIRMATION = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"TRAFFIC_FINE_PAYMENT_CONFIRMATION")]
        TRAFFIC_FINE_PAYMENT_CONFIRMATION = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"REFUND_REQUEST")]
        REFUND_REQUEST = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"REFUND_REVERSAL")]
        REFUND_REVERSAL = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"REFUND_CONFIRMATION")]
        REFUND_CONFIRMATION = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"BILLER_LIST_REQUEST")]
        BILLER_LIST_REQUEST = 13,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum LedgerAmountLedgerIndicator
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT")]
        DEBIT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentMethodProxyType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"MSISDN")]
        MSISDN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EMAIL")]
        EMAIL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PaymentResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyLookupRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyLookupRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyLookupRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyLookupResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyLookupResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyLookupResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyPaymentRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyPaymentRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyPaymentRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyPaymentResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyPaymentResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PolicyPaymentResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PosEntryModePanEntryMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MANUAL")]
        MANUAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"MAGSTRIPE_NO_CVV")]
        MAGSTRIPE_NO_CVV = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"BARCODE")]
        BARCODE = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"OCR")]
        OCR = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ICC_CVV")]
        ICC_CVV = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"CONTACTLESS_ICC")]
        CONTACTLESS_ICC = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"MAGSTRIPE_CVV")]
        MAGSTRIPE_CVV = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"CONTACTLESS_MAGSTRIPE")]
        CONTACTLESS_MAGSTRIPE = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"ICC_NO_CVV")]
        ICC_NO_CVV = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"ORIG_MODE")]
        ORIG_MODE = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"FALLBACK")]
        FALLBACK = 11,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PosEntryModePinEntryCapability
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CAN_ACCEPT")]
        CAN_ACCEPT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CANNOT_ACCEPT")]
        CANNOT_ACCEPT = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PosInfoPosConditionCode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NORMAL_PRESENTMENT")]
        NORMAL_PRESENTMENT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_NOT_PRESENT")]
        CUSTOMER_NOT_PRESENT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_PRESENT_AND_CARD_NOT_PRESENT")]
        CUSTOMER_PRESENT_AND_CARD_NOT_PRESENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_IDENTITY_VERIFIED")]
        CUSTOMER_IDENTITY_VERIFIED = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC_UTILITY_TERMINAL")]
        PUBLIC_UTILITY_TERMINAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER_TERMINAL")]
        CUSTOMER_TERMINAL = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"MANUAL_REVERSAL")]
        MANUAL_REVERSAL = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"UNATTENDED_TERMINAL_AND_CARD_CAN_BE_RETAINED")]
        UNATTENDED_TERMINAL_AND_CARD_CAN_BE_RETAINED = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"UNATTENDED_TERMINAL_AND_CARD_CANNOT_BE_RETAINED")]
        UNATTENDED_TERMINAL_AND_CARD_CANNOT_BE_RETAINED = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RefundResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TenderAccountType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TenderType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CASH")]
        CASH = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_CARD")]
        CREDIT_CARD = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_CARD")]
        DEBIT_CARD = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"WALLET")]
        WALLET = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ROUNDING")]
        ROUNDING = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"LOYALTY_CARD")]
        LOYALTY_CARD = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"OTHER")]
        OTHER = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"REWARD")]
        REWARD = 9,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThreeDSecureDataCardHolderAuthVerificationResult
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_PASSED")]
        CAVV_VALIDATION_PASSED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_FAILED_ISSUER_SYSTEM_ERROR")]
        CAVV_VALIDATION_FAILED_ISSUER_SYSTEM_ERROR = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_FAILED_ISSUER_ATTEMPT_INCOMPLETE")]
        CAVV_VALIDATION_FAILED_ISSUER_ATTEMPT_INCOMPLETE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_NOT_VALIDATED")]
        CAVV_NOT_VALIDATED = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_NOT_VALIDATED_INVALID_DATA")]
        CAVV_NOT_VALIDATED_INVALID_DATA = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CAVV_VALIDATION_FAILED")]
        CAVV_VALIDATION_FAILED = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThreeDSecureDataEci
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_00")]
        AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_00 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ENABLED_01")]
        AUTHENTICATION_NOT_ENABLED_01 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_SUCCESSFUL_02")]
        AUTHENTICATION_SUCCESSFUL_02 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_SUCCESSFUL_05")]
        AUTHENTICATION_SUCCESSFUL_05 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ENABLED_06")]
        AUTHENTICATION_NOT_ENABLED_06 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_07")]
        AUTHENTICATION_NOT_ATTEMPTED_OR_UNSUCCESSFUL_07 = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThreeDSecureDataTransactionStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Y")]
        Y = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"N")]
        N = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"U")]
        U = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"A")]
        A = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"C")]
        C = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"D")]
        D = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"R")]
        R = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"I")]
        I = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"S")]
        S = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFineLookupRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFineLookupRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFineLookupRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFineLookupResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFineLookupResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFineLookupResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFinePaymentRequestTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFinePaymentRequestSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFinePaymentRequestDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFinePaymentResponseTranType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES")]
        GOODS_AND_SERVICES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CASH_WITHDRAWAL")]
        CASH_WITHDRAWAL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DEBIT_ADJUSTMENT")]
        DEBIT_ADJUSTMENT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"GOODS_AND_SERVICES_WITH_CASH_BACK")]
        GOODS_AND_SERVICES_WITH_CASH_BACK = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NON_CASH")]
        NON_CASH = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RETURNS")]
        RETURNS = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"DEPOSIT")]
        DEPOSIT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT_ADJUSTMENT")]
        CREDIT_ADJUSTMENT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_CREDIT")]
        GENERAL_CREDIT = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AVAILABLE_FUNDS_INQUIRY")]
        AVAILABLE_FUNDS_INQUIRY = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BALANCE_INQUIRY")]
        BALANCE_INQUIRY = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_INQUIRY")]
        GENERAL_INQUIRY = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_VERIFICATION_INQUIRY")]
        CARD_VERIFICATION_INQUIRY = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"CARDHOLDER_ACCOUNTS_TRANSFER")]
        CARDHOLDER_ACCOUNTS_TRANSFER = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_TRANSFER")]
        GENERAL_TRANSFER = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_PAYMENT")]
        GENERAL_PAYMENT = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_TO_ACCOUNT")]
        PAYMENT_TO_ACCOUNT = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_FROM_ACCOUNT_TO_ACCOUNT")]
        PAYMENT_FROM_ACCOUNT_TO_ACCOUNT = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PLACE_HOLD_ON_CARD")]
        PLACE_HOLD_ON_CARD = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"GENERAL_ADMIN")]
        GENERAL_ADMIN = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"CHANGE_PIN")]
        CHANGE_PIN = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"CARD_HOLDER_INQUIRY")]
        CARD_HOLDER_INQUIRY = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_INQUIRY")]
        POINTS_INQUIRY = 23,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFinePaymentResponseSrcAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TrafficFinePaymentResponseDestAccType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DEFAULT")]
        DEFAULT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SAVINGS")]
        SAVINGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CHEQUE")]
        CHEQUE = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CREDIT")]
        CREDIT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"UNIVERSAL")]
        UNIVERSAL = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"ELECTRONIC_PURSE")]
        ELECTRONIC_PURSE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"GIFT_CARD")]
        GIFT_CARD = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"STORED_VALUE")]
        STORED_VALUE = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface, AllowMultiple = true)]
    internal class JsonInheritanceAttribute : System.Attribute
    {
        public JsonInheritanceAttribute(string key, System.Type type)
        {
            Key = key;
            Type = type;
        }

        public string Key { get; }

        public System.Type Type { get; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public class JsonInheritanceConverter : Newtonsoft.Json.JsonConverter
    {
        internal static readonly string DefaultDiscriminatorName = "discriminator";

        private readonly string _discriminatorName;

        [System.ThreadStatic]
        private static bool _isReading;

        [System.ThreadStatic]
        private static bool _isWriting;

        public JsonInheritanceConverter()
        {
            _discriminatorName = DefaultDiscriminatorName;
        }

        public JsonInheritanceConverter(string discriminatorName)
        {
            _discriminatorName = discriminatorName;
        }

        public string DiscriminatorName { get { return _discriminatorName; } }

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer)
        {
            try
            {
                _isWriting = true;

                var jObject = Newtonsoft.Json.Linq.JObject.FromObject(value, serializer);
                jObject.AddFirst(new Newtonsoft.Json.Linq.JProperty(_discriminatorName, GetSubtypeDiscriminator(value.GetType())));
                writer.WriteToken(jObject.CreateReader());
            }
            finally
            {
                _isWriting = false;
            }
        }

        public override bool CanWrite
        {
            get
            {
                if (_isWriting)
                {
                    _isWriting = false;
                    return false;
                }
                return true;
            }
        }

        public override bool CanRead
        {
            get
            {
                if (_isReading)
                {
                    _isReading = false;
                    return false;
                }
                return true;
            }
        }

        public override bool CanConvert(System.Type objectType)
        {
            return true;
        }

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            var jObject = serializer.Deserialize<Newtonsoft.Json.Linq.JObject>(reader);
            if (jObject == null)
                return null;

            var discriminatorValue = jObject.GetValue(_discriminatorName);
            var discriminator = discriminatorValue != null ? Newtonsoft.Json.Linq.Extensions.Value<string>(discriminatorValue) : null;
            var subtype = GetObjectSubtype(objectType, discriminator);

            var objectContract = serializer.ContractResolver.ResolveContract(subtype) as Newtonsoft.Json.Serialization.JsonObjectContract;
            if (objectContract == null || System.Linq.Enumerable.All(objectContract.Properties, p => p.PropertyName != _discriminatorName))
            {
                jObject.Remove(_discriminatorName);
            }

            try
            {
                _isReading = true;
                return serializer.Deserialize(jObject.CreateReader(), subtype);
            }
            finally
            {
                _isReading = false;
            }
        }

        private System.Type GetObjectSubtype(System.Type objectType, string discriminator)
        {
            foreach (var attribute in System.Reflection.CustomAttributeExtensions.GetCustomAttributes<JsonInheritanceAttribute>(System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType), true))
            {
                if (attribute.Key == discriminator)
                    return attribute.Type;
            }

            return objectType;
        }

        private string GetSubtypeDiscriminator(System.Type objectType)
        {
            foreach (var attribute in System.Reflection.CustomAttributeExtensions.GetCustomAttributes<JsonInheritanceAttribute>(System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType), true))
            {
                if (attribute.Type == objectType)
                    return attribute.Key;
            }

            return objectType.Name;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    internal class DateFormatConverter : Newtonsoft.Json.Converters.IsoDateTimeConverter
    {
        public DateFormatConverter()
        {
            DateTimeFormat = "yyyy-MM-dd";
        }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016
#pragma warning restore 8603